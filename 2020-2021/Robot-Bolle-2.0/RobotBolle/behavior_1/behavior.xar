<?xml version="1.0" encoding="UTF-8" ?>
<ChoregrapheProject xmlns="http://www.ald.softbankrobotics.com/schema/choregraphe/project.xsd" xar_version="3">
  <Box name="root" id="-1" localization="8" tooltip="Root box of Choregraphe&apos;s behavior. Highest level possible." x="0" y="0">
    <bitmap>media/images/box/root.png</bitmap>
    <script language="4">
      <content>
        <![CDATA[]]>
      </content>
    </script>
    <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
    <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
    <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
    <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
    <Timeline enable="0">
      <BehaviorLayer name="behavior_layer1">
        <BehaviorKeyframe name="keyframe1" index="1">
          <Diagram>
            <Box name="utils" id="1" localization="8" tooltip="" x="556" y="16">
              <bitmap>media/images/box/box-python-script.png</bitmap>
              <script language="4">
                <content>
                  <![CDATA["""Provides some utilities widely used by other modules"""

import bisect
import collections
import abc #import collections.abc
import functools
import heapq
import operator
import os.path
import random
from itertools import chain, combinations

# ______________________________________________________________________________
# Functions on Sequences and Iterables


def sequence(iterable):
    """Converts iterable to sequence, if it is not already one."""
    return iterable if isinstance(iterable, collections.abc.Sequence) else tuple([iterable])


def remove_all(item, seq):
    """Return a copy of seq (or string) with all occurrences of item removed."""
    if isinstance(seq, str):
        return seq.replace(item, '')
    elif isinstance(seq, set):
        rest = seq.copy()
        rest.remove(item)
        return rest
    else:
        return [x for x in seq if x != item]


def unique(seq):
    """Remove duplicate elements from seq. Assumes hashable elements."""
    return list(set(seq))


def count(seq):
    """Count the number of items in sequence that are interpreted as true."""
    return sum(map(bool, seq))


def multimap(items):
    """Given (key, val) pairs, return {key: [val, ....], ...}."""
    result = collections.defaultdict(list)
    for (key, val) in items:
        result[key].append(val)
    return dict(result)


def multimap_items(mmap):
    """Yield all (key, val) pairs stored in the multimap."""
    for (key, vals) in mmap.items():
        for val in vals:
            yield key, val


def product(numbers):
    """Return the product of the numbers, e.g. product([2, 3, 10]) == 60"""
    result = 1
    for x in numbers:
        result *= x
    return result


def first(iterable, default=None):
    """Return the first element of an iterable; or default."""
    return next(iter(iterable), default)


def is_in(elt, seq):
    """Similar to (elt in seq), but compares with 'is', not '=='."""
    return any(x is elt for x in seq)


def mode(data):
    """Return the most common data item. If there are ties, return any one of them."""
    [(item, count)] = collections.Counter(data).most_common(1)
    return item


def power_set(iterable):
    """power_set([1,2,3]) --> (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"""
    s = list(iterable)
    return list(chain.from_iterable(combinations(s, r) for r in range(len(s) + 1)))[1:]


def flatten(seqs):
    return sum(seqs, [])


# ______________________________________________________________________________
# argmin and argmax

identity = lambda x: x


def argmin_random_tie(seq, key=identity):
    """Return a minimum element of seq; break ties at random."""
    return min(shuffled(seq), key=key)


def argmax_random_tie(seq, key=identity):
    """Return an element with highest fn(seq[i]) score; break ties at random."""
    return max(shuffled(seq), key=key)


def shuffled(iterable):
    """Randomly shuffle a copy of iterable."""
    items = list(iterable)
    random.shuffle(items)
    return items


# ______________________________________________________________________________
# Statistical and mathematical functions


def histogram(values, mode=0, bin_function=None):
    """Return a list of (value, count) pairs, summarizing the input values.
    Sorted by increasing value, or if mode=1, by decreasing count.
    If bin_function is given, map it over values first."""
    if bin_function:
        values = map(bin_function, values)

    bins = {}
    for val in values:
        bins[val] = bins.get(val, 0) + 1

    if mode:
        return sorted(list(bins.items()), key=lambda x: (x[1], x[0]), reverse=True)
    else:
        return sorted(bins.items())


def dot_product(x, y):
    """Return the sum of the element-wise product of vectors x and y."""
    return sum(_x * _y for _x, _y in zip(x, y))


def element_wise_product(x, y):
    """Return vector as an element-wise product of vectors x and y."""
    assert len(x) == len(y)
    return np.multiply(x, y)


def matrix_multiplication(x, *y):
    """Return a matrix as a matrix-multiplication of x and arbitrary number of matrices *y."""

    result = x
    for _y in y:
        result = np.matmul(result, _y)

    return result


def vector_add(a, b):
    """Component-wise addition of two vectors."""
    return tuple(map(operator.add, a, b))


def scalar_vector_product(x, y):
    """Return vector as a product of a scalar and a vector"""
    return np.multiply(x, y)


def probability(p):
    """Return true with probability p."""
    return p > random.uniform(0.0, 1.0)


def weighted_sample_with_replacement(n, seq, weights):
    """Pick n samples from seq at random, with replacement, with the
    probability of each element in proportion to its corresponding
    weight."""
    sample = weighted_sampler(seq, weights)
    return [sample() for _ in range(n)]


def weighted_sampler(seq, weights):
    """Return a random-sample function that picks from seq weighted by weights."""
    totals = []
    for w in weights:
        totals.append(w + totals[-1] if totals else w)
    return lambda: seq[bisect.bisect(totals, random.uniform(0, totals[-1]))]


def weighted_choice(choices):
    """A weighted version of random.choice"""
    # NOTE: should be replaced by random.choices if we port to Python 3.6

    total = sum(w for _, w in choices)
    r = random.uniform(0, total)
    upto = 0
    for c, w in choices:
        if upto + w >= r:
            return c, w
        upto += w


def rounder(numbers, d=4):
    """Round a single number, or sequence of numbers, to d decimal places."""
    if isinstance(numbers, (int, float)):
        return round(numbers, d)
    else:
        constructor = type(numbers)  # Can be list, set, tuple, etc.
        return constructor(rounder(n, d) for n in numbers)


def num_or_str(x):  # TODO: rename as `atom`
    """The argument is a string; convert to a number if possible, or strip it."""
    try:
        return int(x)
    except ValueError:
        try:
            return float(x)
        except ValueError:
            return str(x).strip()


def euclidean_distance(x, y):
    return np.sqrt(sum((_x - _y) ** 2 for _x, _y in zip(x, y)))


def manhattan_distance(x, y):
    return sum(abs(_x - _y) for _x, _y in zip(x, y))


def hamming_distance(x, y):
    return sum(_x != _y for _x, _y in zip(x, y))


def cross_entropy_loss(x, y):
    return (-1.0 / len(x)) * sum(_x * np.log(_y) + (1 - _x) * np.log(1 - _y) for _x, _y in zip(x, y))


def mean_squared_error_loss(x, y):
    return (1.0 / len(x)) * sum((_x - _y) ** 2 for _x, _y in zip(x, y))


def rms_error(x, y):
    return np.sqrt(ms_error(x, y))


def ms_error(x, y):
    return mean((_x - _y) ** 2 for _x, _y in zip(x, y))


def mean_error(x, y):
    return mean(abs(_x - _y) for _x, _y in zip(x, y))


def mean_boolean_error(x, y):
    return mean(_x != _y for _x, _y in zip(x, y))


def normalize(dist):
    """Multiply each number by a constant such that the sum is 1.0"""
    if isinstance(dist, dict):
        total = sum(dist.values())
        for key in dist:
            dist[key] = dist[key] / total
            assert 0 <= dist[key] <= 1  # probabilities must be between 0 and 1
        return dist
    total = sum(dist)
    return [(n / total) for n in dist]


def random_weights(min_value, max_value, num_weights):
    return [random.uniform(min_value, max_value) for _ in range(num_weights)]


def sigmoid(x):
    """Return activation value of x with sigmoid function."""
    return 1 / (1 + np.exp(-x))


def sigmoid_derivative(value):
    return value * (1 - value)


def elu(x, alpha=0.01):
    return x if x > 0 else alpha * (np.exp(x) - 1)


def elu_derivative(value, alpha=0.01):
    return 1 if value > 0 else alpha * np.exp(value)


def tanh(x):
    return np.tanh(x)


def tanh_derivative(value):
    return 1 - (value ** 2)


def leaky_relu(x, alpha=0.01):
    return x if x > 0 else alpha * x


def leaky_relu_derivative(value, alpha=0.01):
    return 1 if value > 0 else alpha


def relu(x):
    return max(0, x)


def relu_derivative(value):
    return 1 if value > 0 else 0


def step(x):
    """Return activation value of x with sign function"""
    return 1 if x >= 0 else 0


def gaussian(mean, st_dev, x):
    """Given the mean and standard deviation of a distribution, it returns the probability of x."""
    return 1 / (np.sqrt(2 * np.pi) * st_dev) * np.e ** (-0.5 * (float(x - mean) / st_dev) ** 2)


def linear_kernel(x, y=None):
    if y is None:
        y = x
    return np.dot(x, y.T)


def polynomial_kernel(x, y=None, degree=2.0):
    if y is None:
        y = x
    return (1.0 + np.dot(x, y.T)) ** degree


def rbf_kernel(x, y=None, gamma=None):
    """Radial-basis function kernel (aka squared-exponential kernel)."""
    if y is None:
        y = x
    if gamma is None:
        gamma = 1.0 / x.shape[1]  # 1.0 / n_features
    return np.exp(-gamma * (-2.0 * np.dot(x, y.T) +
                            np.sum(x * x, axis=1).reshape((-1, 1)) + np.sum(y * y, axis=1).reshape((1, -1))))


# ______________________________________________________________________________
# Grid Functions


orientations = EAST, NORTH, WEST, SOUTH = [(1, 0), (0, 1), (-1, 0), (0, -1)]
turns = LEFT, RIGHT = (+1, -1)


def turn_heading(heading, inc, headings=orientations):
    return headings[(headings.index(heading) + inc) % len(headings)]


def turn_right(heading):
    return turn_heading(heading, RIGHT)


def turn_left(heading):
    return turn_heading(heading, LEFT)


def distance(a, b):
    """The distance between two (x, y) points."""
    xA, yA = a
    xB, yB = b
    return np.hypot((xA - xB), (yA - yB))


def distance_squared(a, b):
    """The square of the distance between two (x, y) points."""
    xA, yA = a
    xB, yB = b
    return (xA - xB) ** 2 + (yA - yB) ** 2


# ______________________________________________________________________________
# Misc Functions

class injection:
    """Dependency injection of temporary values for global functions/classes/etc.
    E.g., `with injection(DataBase=MockDataBase): ...`"""

    def __init__(self, **kwds):
        self.new = kwds

    def __enter__(self):
        self.old = {v: globals()[v] for v in self.new}
        globals().update(self.new)

    def __exit__(self, type, value, traceback):
        globals().update(self.old)


def memoize(fn, slot=None, maxsize=32):
    """Memoize fn: make it remember the computed value for any argument list.
    If slot is specified, store result in that slot of first argument.
    If slot is false, use lru_cache for caching the values."""
    if slot:
        def memoized_fn(obj, *args):
            if hasattr(obj, slot):
                return getattr(obj, slot)
            else:
                val = fn(obj, *args)
                setattr(obj, slot, val)
                return val
    else:
        @functools.lru_cache(maxsize=maxsize)
        def memoized_fn(*args):
            return fn(*args)

    return memoized_fn


def name(obj):
    """Try to find some reasonable name for the object."""
    return (getattr(obj, 'name', 0) or getattr(obj, '__name__', 0) or
            getattr(getattr(obj, '__class__', 0), '__name__', 0) or
            str(obj))


def isnumber(x):
    """Is x a number?"""
    return hasattr(x, '__int__')


def issequence(x):
    """Is x a sequence?"""
    return isinstance(x, collections.abc.Sequence)


def print_table(table, header=None, sep='   ', numfmt='{}'):
    """Print a list of lists as a table, so that columns line up nicely.
    header, if specified, will be printed as the first row.
    numfmt is the format for all numbers; you might want e.g. '{:.2f}'.
    (If you want different formats in different columns,
    don't use print_table.) sep is the separator between columns."""
    justs = ['rjust' if isnumber(x) else 'ljust' for x in table[0]]

    if header:
        table.insert(0, header)

    table = [[numfmt.format(x) if isnumber(x) else x for x in row]
             for row in table]

    sizes = list(map(lambda seq: max(map(len, seq)), list(zip(*[map(str, row) for row in table]))))

    for row in table:
        print(sep.join(getattr(str(x), j)(size) for (j, size, x) in zip(justs, sizes, row)))


def open_data(name, mode='r'):
    aima_root = os.path.dirname(__file__)
    aima_file = os.path.join(aima_root, *['aima-data', name])

    return open(aima_file, mode=mode)


def failure_test(algorithm, tests):
    """Grades the given algorithm based on how many tests it passes.
    Most algorithms have arbitrary output on correct execution, which is difficult
    to check for correctness. On the other hand, a lot of algorithms output something
    particular on fail (for example, False, or None).
    tests is a list with each element in the form: (values, failure_output)."""
    return mean(int(algorithm(x) != y) for x, y in tests)


# ______________________________________________________________________________
# Expressions

# See https://docs.python.org/3/reference/expressions.html#operator-precedence
# See https://docs.python.org/3/reference/datamodel.html#special-method-names

class Expr:
    """A mathematical expression with an operator and 0 or more arguments.
    op is a str like '+' or 'sin'; args are Expressions.
    Expr('x') or Symbol('x') creates a symbol (a nullary Expr).
    Expr('-', x) creates a unary; Expr('+', x, 1) creates a binary."""

    def __init__(self, op, *args):
        self.op = str(op)
        self.args = args

    # Operator overloads
    def __neg__(self):
        return Expr('-', self)

    def __pos__(self):
        return Expr('+', self)

    def __invert__(self):
        return Expr('~', self)

    def __add__(self, rhs):
        return Expr('+', self, rhs)

    def __sub__(self, rhs):
        return Expr('-', self, rhs)

    def __mul__(self, rhs):
        return Expr('*', self, rhs)

    def __pow__(self, rhs):
        return Expr('**', self, rhs)

    def __mod__(self, rhs):
        return Expr('%', self, rhs)

    def __and__(self, rhs):
        return Expr('&', self, rhs)

    def __xor__(self, rhs):
        return Expr('^', self, rhs)

    def __rshift__(self, rhs):
        return Expr('>>', self, rhs)

    def __lshift__(self, rhs):
        return Expr('<<', self, rhs)

    def __truediv__(self, rhs):
        return Expr('/', self, rhs)

    def __floordiv__(self, rhs):
        return Expr('//', self, rhs)

    def __matmul__(self, rhs):
        return Expr('@', self, rhs)

    def __or__(self, rhs):
        """Allow both P | Q, and P |'==>'| Q."""
        if isinstance(rhs, Expression):
            return Expr('|', self, rhs)
        else:
            return PartialExpr(rhs, self)

    # Reverse operator overloads
    def __radd__(self, lhs):
        return Expr('+', lhs, self)

    def __rsub__(self, lhs):
        return Expr('-', lhs, self)

    def __rmul__(self, lhs):
        return Expr('*', lhs, self)

    def __rdiv__(self, lhs):
        return Expr('/', lhs, self)

    def __rpow__(self, lhs):
        return Expr('**', lhs, self)

    def __rmod__(self, lhs):
        return Expr('%', lhs, self)

    def __rand__(self, lhs):
        return Expr('&', lhs, self)

    def __rxor__(self, lhs):
        return Expr('^', lhs, self)

    def __ror__(self, lhs):
        return Expr('|', lhs, self)

    def __rrshift__(self, lhs):
        return Expr('>>', lhs, self)

    def __rlshift__(self, lhs):
        return Expr('<<', lhs, self)

    def __rtruediv__(self, lhs):
        return Expr('/', lhs, self)

    def __rfloordiv__(self, lhs):
        return Expr('//', lhs, self)

    def __rmatmul__(self, lhs):
        return Expr('@', lhs, self)

    def __call__(self, *args):
        """Call: if 'f' is a Symbol, then f(0) == Expr('f', 0)."""
        if self.args:
            raise ValueError('Can only do a call for a Symbol, not an Expr')
        else:
            return Expr(self.op, *args)

    # Equality and repr
    def __eq__(self, other):
        """x == y' evaluates to True or False; does not build an Expr."""
        return isinstance(other, Expr) and self.op == other.op and self.args == other.args

    def __lt__(self, other):
        return isinstance(other, Expr) and str(self) < str(other)

    def __hash__(self):
        return hash(self.op) ^ hash(self.args)

    def __repr__(self):
        op = self.op
        args = [str(arg) for arg in self.args]
        if op.isidentifier():  # f(x) or f(x, y)
            return '{}({})'.format(op, ', '.join(args)) if args else op
        elif len(args) == 1:  # -x or -(x + 1)
            return op + args[0]
        else:  # (x - y)
            opp = (' ' + op + ' ')
            return '(' + opp.join(args) + ')'


# An 'Expression' is either an Expr or a Number.
# Symbol is not an explicit type; it is any Expr with 0 args.


Number = (int, float, complex)
Expression = (Expr, Number)


def Symbol(name):
    """A Symbol is just an Expr with no args."""
    return Expr(name)


def symbols(names):
    """Return a tuple of Symbols; names is a comma/whitespace delimited str."""
    return tuple(Symbol(name) for name in names.replace(',', ' ').split())


def arity(expression):
    """The number of sub-expressions in this expression."""
    if isinstance(expression, Expr):
        return len(expression.args)
    else:  # expression is a number
        return 0


# For operators that are not defined in Python, we allow new InfixOps:


class PartialExpr:
    """Given 'P |'==>'| Q, first form PartialExpr('==>', P), then combine with Q."""

    def __init__(self, op, lhs):
        self.op, self.lhs = op, lhs

    def __or__(self, rhs):
        return Expr(self.op, self.lhs, rhs)

    def __repr__(self):
        return "PartialExpr('{}', {})".format(self.op, self.lhs)


def expr(x):
    """Shortcut to create an Expression. x is a str in which:
    - identifiers are automatically defined as Symbols.
    - ==> is treated as an infix |'==>'|, as are <== and <=>.
    If x is already an Expression, it is returned unchanged. Example:
    >>> expr('P & Q ==> Q')
    ((P & Q) ==> Q)
    """
    return eval(expr_handle_infix_ops(x), defaultkeydict(Symbol)) if isinstance(x, str) else x


infix_ops = '==> <== <=>'.split()


def expr_handle_infix_ops(x):
    """Given a str, return a new str with ==> replaced by |'==>'|, etc.
    >>> expr_handle_infix_ops('P ==> Q')
    "P |'==>'| Q"
    """
    for op in infix_ops:
        x = x.replace(op, '|' + repr(op) + '|')
    return x


class defaultkeydict(collections.defaultdict):
    """Like defaultdict, but the default_factory is a function of the key.
    >>> d = defaultkeydict(len); d['four']
    4
    """

    def __missing__(self, key):
        self[key] = result = self.default_factory(key)
        return result


class hashabledict(dict):
    """Allows hashing by representing a dictionary as tuple of key:value pairs.
    May cause problems as the hash value may change during runtime."""

    def __hash__(self):
        return 1


# ______________________________________________________________________________
# Queues: Stack, FIFOQueue, PriorityQueue
# Stack and FIFOQueue are implemented as list and collection.deque
# PriorityQueue is implemented here


class PriorityQueue:
    """A Queue in which the minimum (or maximum) element (as determined by f and
    order) is returned first.
    If order is 'min', the item with minimum f(x) is
    returned first; if order is 'max', then it is the item with maximum f(x).
    Also supports dict-like lookup."""

    def __init__(self, order='min', f=lambda x: x):
        self.heap = []
        if order == 'min':
            self.f = f
        elif order == 'max':  # now item with max f(x)
            self.f = lambda x: -f(x)  # will be popped first
        else:
            raise ValueError("Order must be either 'min' or 'max'.")

    def append(self, item):
        """Insert item at its correct position."""
        heapq.heappush(self.heap, (self.f(item), item))

    def extend(self, items):
        """Insert each item in items at its correct position."""
        for item in items:
            self.append(item)

    def pop(self):
        """Pop and return the item (with min or max f(x) value)
        depending on the order."""
        if self.heap:
            return heapq.heappop(self.heap)[1]
        else:
            raise Exception('Trying to pop from empty PriorityQueue.')

    def __len__(self):
        """Return current capacity of PriorityQueue."""
        return len(self.heap)

    def __contains__(self, key):
        """Return True if the key is in PriorityQueue."""
        return any([item == key for _, item in self.heap])

    def __getitem__(self, key):
        """Returns the first value associated with key in PriorityQueue.
        Raises KeyError if key is not present."""
        for value, item in self.heap:
            if item == key:
                return value
        raise KeyError(str(key) + " is not in the priority queue")

    def __delitem__(self, key):
        """Delete the first occurrence of key."""
        try:
            del self.heap[[item == key for _, item in self.heap].index(True)]
        except ValueError:
            raise KeyError(str(key) + " is not in the priority queue")
        heapq.heapify(self.heap)


# ______________________________________________________________________________
# Useful Shorthands


class Bool(int):
    """Just like `bool`, except values display as 'T' and 'F' instead of 'True' and 'False'."""
    __str__ = __repr__ = lambda self: 'T' if self else 'F'


T = Bool(True)
F = Bool(False)]]>
                </content>
              </script>
              <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
              <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
              <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
              <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
            </Box>
            <Box name="search" id="2" localization="8" tooltip="" x="440" y="12">
              <bitmap>media/images/box/box-python-script.png</bitmap>
              <script language="4">
                <content>
                  <![CDATA["""
Search (Chapters 3-4)

The way to use this code is to subclass Problem to create a class of problems,
then create problem instances and solve them with calls to the various search
functions.
"""

import sys
from collections import deque



class Problem:
    """The abstract class for a formal problem. You should subclass
    this and implement the methods actions and result, and possibly
    __init__, goal_test, and path_cost. Then you will create instances
    of your subclass and solve them with the various search functions."""

    def __init__(self, initial, goal=None):
        """The constructor specifies the initial state, and possibly a goal
        state, if there is a unique goal. Your subclass's constructor can add
        other arguments."""
        self.initial = initial
        self.goal = goal

    def actions(self, state):
        """Return the actions that can be executed in the given
        state. The result would typically be a list, but if there are
        many actions, consider yielding them one at a time in an
        iterator, rather than building them all at once."""
        raise NotImplementedError

    def result(self, state, action):
        """Return the state that results from executing the given
        action in the given state. The action must be one of
        self.actions(state)."""
        raise NotImplementedError

    def goal_test(self, state):
        """Return True if the state is a goal. The default method compares the
        state to self.goal or checks for state in self.goal if it is a
        list, as specified in the constructor. Override this method if
        checking against a single self.goal is not enough."""
        if isinstance(self.goal, list):
            return is_in(state, self.goal)
        else:
            return state == self.goal

    def path_cost(self, c, state1, action, state2):
        """Return the cost of a solution path that arrives at state2 from
        state1 via action, assuming cost c to get up to state1. If the problem
        is such that the path doesn't matter, this function will only look at
        state2. If the path does matter, it will consider c and maybe state1
        and action. The default method costs 1 for every step in the path."""
        return c + 1

    def value(self, state):
        """For optimization problems, each state has a value. Hill Climbing
        and related algorithms try to maximize this value."""
        raise NotImplementedError


# ______________________________________________________________________________


class Node:
    """A node in a search tree. Contains a pointer to the parent (the node
    that this is a successor of) and to the actual state for this node. Note
    that if a state is arrived at by two paths, then there are two nodes with
    the same state. Also includes the action that got us to this state, and
    the total path_cost (also known as g) to reach the node. Other functions
    may add an f and h value; see best_first_graph_search and astar_search for
    an explanation of how the f and h values are handled. You will not need to
    subclass this class."""

    def __init__(self, state, parent=None, action=None, path_cost=0):
        """Create a search tree Node, derived from a parent by an action."""
        self.state = state
        self.parent = parent
        self.action = action
        self.path_cost = path_cost
        self.depth = 0
        if parent:
            self.depth = parent.depth + 1

    def __repr__(self):
        return "<Node {}>".format(self.state)

    def __lt__(self, node):
        return self.state < node.state

    def expand(self, problem):
        """List the nodes reachable in one step from this node."""
        return [self.child_node(problem, action)
                for action in problem.actions(self.state)]

    def child_node(self, problem, action):
        """[Figure 3.10]"""
        next_state = problem.result(self.state, action)
        next_node = Node(next_state, self, action, problem.path_cost(self.path_cost, self.state, action, next_state))
        return next_node

    def solution(self):
        """Return the sequence of actions to go from the root to this node."""
        return [node.action for node in self.path()[1:]]

    def path(self):
        """Return a list of nodes forming the path from the root to this node."""
        node, path_back = self, []
        while node:
            path_back.append(node)
            node = node.parent
        return list(reversed(path_back))

    # We want for a queue of nodes in breadth_first_graph_search or
    # astar_search to have no duplicated states, so we treat nodes
    # with the same state as equal. [Problem: this may not be what you
    # want in other contexts.]

    def __eq__(self, other):
        return isinstance(other, Node) and self.state == other.state

    def __hash__(self):
        # We use the hash value of the state
        # stored in the node instead of the node
        # object itself to quickly search a node
        # with the same state in a Hash Table
        return hash(self.state)


# ______________________________________________________________________________


class SimpleProblemSolvingAgentProgram:
    """
    [Figure 3.1]
    Abstract framework for a problem-solving agent.
    """

    def __init__(self, initial_state=None):
        """State is an abstract representation of the state
        of the world, and seq is the list of actions required
        to get to a particular state from the initial state(root)."""
        self.state = initial_state
        self.seq = []

    def __call__(self, percept):
        """[Figure 3.1] Formulate a goal and problem, then
        search for a sequence of actions to solve it."""
        self.state = self.update_state(self.state, percept)
        if not self.seq:
            goal = self.formulate_goal(self.state)
            problem = self.formulate_problem(self.state, goal)
            self.seq = self.search(problem)
            if not self.seq:
                return None
        return self.seq.pop(0)

    def update_state(self, state, percept):
        raise NotImplementedError

    def formulate_goal(self, state):
        raise NotImplementedError

    def formulate_problem(self, state, goal):
        raise NotImplementedError

    def search(self, problem):
        raise NotImplementedError


# ______________________________________________________________________________
# Uninformed Search algorithms


def breadth_first_tree_search(problem):
    """
    [Figure 3.7]
    Search the shallowest nodes in the search tree first.
    Search through the successors of a problem to find a goal.
    The argument frontier should be an empty queue.
    Repeats infinitely in case of loops.
    """

    frontier = deque([Node(problem.initial)])  # FIFO queue

    while frontier:
        node = frontier.popleft()
        if problem.goal_test(node.state):
            return node
        frontier.extend(node.expand(problem))
    return None


def depth_first_tree_search(problem):
    """
    [Figure 3.7]
    Search the deepest nodes in the search tree first.
    Search through the successors of a problem to find a goal.
    The argument frontier should be an empty queue.
    Repeats infinitely in case of loops.
    """

    frontier = [Node(problem.initial)]  # Stack

    while frontier:
        node = frontier.pop()
        if problem.goal_test(node.state):
            return node
        frontier.extend(node.expand(problem))
    return None


def depth_first_graph_search(problem):
    """
    [Figure 3.7]
    Search the deepest nodes in the search tree first.
    Search through the successors of a problem to find a goal.
    The argument frontier should be an empty queue.
    Does not get trapped by loops.
    If two paths reach a state, only use the first one.
    """
    frontier = [(Node(problem.initial))]  # Stack

    explored = set()
    while frontier:
        node = frontier.pop()
        if problem.goal_test(node.state):
            return node
        explored.add(node.state)
        frontier.extend(child for child in node.expand(problem)
                        if child.state not in explored and child not in frontier)
    return None


def breadth_first_graph_search(problem):
    """[Figure 3.11]
    Note that this function can be implemented in a
    single line as below:
    return graph_search(problem, FIFOQueue())
    """
    node = Node(problem.initial)
    if problem.goal_test(node.state):
        return node
    frontier = deque([node])
    explored = set()
    while frontier:
        node = frontier.popleft()
        explored.add(node.state)
        for child in node.expand(problem):
            if child.state not in explored and child not in frontier:
                if problem.goal_test(child.state):
                    return child
                frontier.append(child)
    return None


def best_first_graph_search(problem, f, display=False):
    """Search the nodes with the lowest f scores first.
    You specify the function f(node) that you want to minimize; for example,
    if f is a heuristic estimate to the goal, then we have greedy best
    first search; if f is node.depth then we have breadth-first search.
    There is a subtlety: the line "f = memoize(f, 'f')" means that the f
    values will be cached on the nodes as they are computed. So after doing
    a best first search you can examine the f values of the path returned."""
    f = memoize(f, 'f')
    node = Node(problem.initial)
    frontier = PriorityQueue('min', f)
    frontier.append(node)
    explored = set()
    while frontier:
        node = frontier.pop()
        if problem.goal_test(node.state):
            if display:
                print(len(explored), "paths have been expanded and", len(frontier), "paths remain in the frontier")
            return node
        explored.add(node.state)
        for child in node.expand(problem):
            if child.state not in explored and child not in frontier:
                frontier.append(child)
            elif child in frontier:
                if f(child) < frontier[child]:
                    del frontier[child]
                    frontier.append(child)
    return None


def uniform_cost_search(problem, display=False):
    """[Figure 3.14]"""
    return best_first_graph_search(problem, lambda node: node.path_cost, display)


def depth_limited_search(problem, limit=50):
    """[Figure 3.17]"""

    def recursive_dls(node, problem, limit):
        if problem.goal_test(node.state):
            return node
        elif limit == 0:
            return 'cutoff'
        else:
            cutoff_occurred = False
            for child in node.expand(problem):
                result = recursive_dls(child, problem, limit - 1)
                if result == 'cutoff':
                    cutoff_occurred = True
                elif result is not None:
                    return result
            return 'cutoff' if cutoff_occurred else None

    # Body of depth_limited_search:
    return recursive_dls(Node(problem.initial), problem, limit)


def iterative_deepening_search(problem):
    """[Figure 3.18]"""
    for depth in range(sys.maxsize):
        result = depth_limited_search(problem, depth)
        if result != 'cutoff':
            return result


# ______________________________________________________________________________
# Bidirectional Search
# Pseudocode from https://webdocs.cs.ualberta.ca/%7Eholte/Publications/MM-AAAI2016.pdf

def bidirectional_search(problem):
    e = 0
    if isinstance(problem, GraphProblem):
        e = problem.find_min_edge()
    gF, gB = {Node(problem.initial): 0}, {Node(problem.goal): 0}
    openF, openB = [Node(problem.initial)], [Node(problem.goal)]
    closedF, closedB = [], []
    U = np.inf

    def extend(U, open_dir, open_other, g_dir, g_other, closed_dir):
        """Extend search in given direction"""
        n = find_key(C, open_dir, g_dir)

        open_dir.remove(n)
        closed_dir.append(n)

        for c in n.expand(problem):
            if c in open_dir or c in closed_dir:
                if g_dir[c] <= problem.path_cost(g_dir[n], n.state, None, c.state):
                    continue

                open_dir.remove(c)

            g_dir[c] = problem.path_cost(g_dir[n], n.state, None, c.state)
            open_dir.append(c)

            if c in open_other:
                U = min(U, g_dir[c] + g_other[c])

        return U, open_dir, closed_dir, g_dir

    def find_min(open_dir, g):
        """Finds minimum priority, g and f values in open_dir"""
        # pr_min_f isn't forward pr_min instead it's the f-value
        # of node with priority pr_min.
        pr_min, pr_min_f = np.inf, np.inf
        for n in open_dir:
            f = g[n] + problem.h(n)
            pr = max(f, 2 * g[n])
            pr_min = min(pr_min, pr)
            pr_min_f = min(pr_min_f, f)

        return pr_min, pr_min_f, min(g.values())

    def find_key(pr_min, open_dir, g):
        """Finds key in open_dir with value equal to pr_min
        and minimum g value."""
        m = np.inf
        node = Node(-1)
        for n in open_dir:
            pr = max(g[n] + problem.h(n), 2 * g[n])
            if pr == pr_min:
                if g[n] < m:
                    m = g[n]
                    node = n

        return node

    while openF and openB:
        pr_min_f, f_min_f, g_min_f = find_min(openF, gF)
        pr_min_b, f_min_b, g_min_b = find_min(openB, gB)
        C = min(pr_min_f, pr_min_b)

        if U <= max(C, f_min_f, f_min_b, g_min_f + g_min_b + e):
            return U

        if C == pr_min_f:
            # Extend forward
            U, openF, closedF, gF = extend(U, openF, openB, gF, gB, closedF)
        else:
            # Extend backward
            U, openB, closedB, gB = extend(U, openB, openF, gB, gF, closedB)

    return np.inf


# ______________________________________________________________________________
# Informed (Heuristic) Search


greedy_best_first_graph_search = best_first_graph_search


# Greedy best-first search is accomplished by specifying f(n) = h(n).


def astar_search(problem, h=None, display=False):
    """A* search is best-first graph search with f(n) = g(n)+h(n).
    You need to specify the h function when you call astar_search, or
    else in your Problem subclass."""
    h = memoize(h or problem.h, 'h')
    return best_first_graph_search(problem, lambda n: n.path_cost + h(n), display)


# ______________________________________________________________________________
# A* heuristics

class EightPuzzle(Problem):
    """ The problem of sliding tiles numbered from 1 to 8 on a 3x3 board, where one of the
    squares is a blank. A state is represented as a tuple of length 9, where  element at
    index i represents the tile number  at index i (0 if it's an empty square) """

    def __init__(self, initial, goal=(1, 2, 3, 4, 5, 6, 7, 8, 0)):
        """ Define goal state and initialize a problem """
        super().__init__(initial, goal)

    def find_blank_square(self, state):
        """Return the index of the blank square in a given state"""

        return state.index(0)

    def actions(self, state):
        """ Return the actions that can be executed in the given state.
        The result would be a list, since there are only four possible actions
        in any given state of the environment """

        possible_actions = ['UP', 'DOWN', 'LEFT', 'RIGHT']
        index_blank_square = self.find_blank_square(state)

        if index_blank_square % 3 == 0:
            possible_actions.remove('LEFT')
        if index_blank_square < 3:
            possible_actions.remove('UP')
        if index_blank_square % 3 == 2:
            possible_actions.remove('RIGHT')
        if index_blank_square > 5:
            possible_actions.remove('DOWN')

        return possible_actions

    def result(self, state, action):
        """ Given state and action, return a new state that is the result of the action.
        Action is assumed to be a valid action in the state """

        # blank is the index of the blank square
        blank = self.find_blank_square(state)
        new_state = list(state)

        delta = {'UP': -3, 'DOWN': 3, 'LEFT': -1, 'RIGHT': 1}
        neighbor = blank + delta[action]
        new_state[blank], new_state[neighbor] = new_state[neighbor], new_state[blank]

        return tuple(new_state)

    def goal_test(self, state):
        """ Given a state, return True if state is a goal state or False, otherwise """

        return state == self.goal

    def check_solvability(self, state):
        """ Checks if the given state is solvable """

        inversion = 0
        for i in range(len(state)):
            for j in range(i + 1, len(state)):
                if (state[i] > state[j]) and state[i] != 0 and state[j] != 0:
                    inversion += 1

        return inversion % 2 == 0

    def h(self, node):
        """ Return the heuristic value for a given state. Default heuristic function used is
        h(n) = number of misplaced tiles """

        return sum(s != g for (s, g) in zip(node.state, self.goal))


# ______________________________________________________________________________


class PlanRoute(Problem):
    """ The problem of moving the Hybrid Wumpus Agent from one place to other """

    def __init__(self, initial, goal, allowed, dimrow):
        """ Define goal state and initialize a problem """
        super().__init__(initial, goal)
        self.dimrow = dimrow
        self.goal = goal
        self.allowed = allowed

    def actions(self, state):
        """ Return the actions that can be executed in the given state.
        The result would be a list, since there are only three possible actions
        in any given state of the environment """

        possible_actions = ['Forward', 'TurnLeft', 'TurnRight']
        x, y = state.get_location()
        orientation = state.get_orientation()

        # Prevent Bumps
        if x == 1 and orientation == 'LEFT':
            if 'Forward' in possible_actions:
                possible_actions.remove('Forward')
        if y == 1 and orientation == 'DOWN':
            if 'Forward' in possible_actions:
                possible_actions.remove('Forward')
        if x == self.dimrow and orientation == 'RIGHT':
            if 'Forward' in possible_actions:
                possible_actions.remove('Forward')
        if y == self.dimrow and orientation == 'UP':
            if 'Forward' in possible_actions:
                possible_actions.remove('Forward')

        return possible_actions

    def result(self, state, action):
        """ Given state and action, return a new state that is the result of the action.
        Action is assumed to be a valid action in the state """
        x, y = state.get_location()
        proposed_loc = list()

        # Move Forward
        if action == 'Forward':
            if state.get_orientation() == 'UP':
                proposed_loc = [x, y + 1]
            elif state.get_orientation() == 'DOWN':
                proposed_loc = [x, y - 1]
            elif state.get_orientation() == 'LEFT':
                proposed_loc = [x - 1, y]
            elif state.get_orientation() == 'RIGHT':
                proposed_loc = [x + 1, y]
            else:
                raise Exception('InvalidOrientation')

        # Rotate counter-clockwise
        elif action == 'TurnLeft':
            if state.get_orientation() == 'UP':
                state.set_orientation('LEFT')
            elif state.get_orientation() == 'DOWN':
                state.set_orientation('RIGHT')
            elif state.get_orientation() == 'LEFT':
                state.set_orientation('DOWN')
            elif state.get_orientation() == 'RIGHT':
                state.set_orientation('UP')
            else:
                raise Exception('InvalidOrientation')

        # Rotate clockwise
        elif action == 'TurnRight':
            if state.get_orientation() == 'UP':
                state.set_orientation('RIGHT')
            elif state.get_orientation() == 'DOWN':
                state.set_orientation('LEFT')
            elif state.get_orientation() == 'LEFT':
                state.set_orientation('UP')
            elif state.get_orientation() == 'RIGHT':
                state.set_orientation('DOWN')
            else:
                raise Exception('InvalidOrientation')

        if proposed_loc in self.allowed:
            state.set_location(proposed_loc[0], [proposed_loc[1]])

        return state

    def goal_test(self, state):
        """ Given a state, return True if state is a goal state or False, otherwise """

        return state.get_location() == tuple(self.goal)

    def h(self, node):
        """ Return the heuristic value for a given state."""

        # Manhattan Heuristic Function
        x1, y1 = node.state.get_location()
        x2, y2 = self.goal

        return abs(x2 - x1) + abs(y2 - y1)


# ______________________________________________________________________________
# Other search algorithms


def recursive_best_first_search(problem, h=None):
    """[Figure 3.26]"""
    h = memoize(h or problem.h, 'h')

    def RBFS(problem, node, flimit):
        if problem.goal_test(node.state):
            return node, 0  # (The second value is immaterial)
        successors = node.expand(problem)
        if len(successors) == 0:
            return None, np.inf
        for s in successors:
            s.f = max(s.path_cost + h(s), node.f)
        while True:
            # Order by lowest f value
            successors.sort(key=lambda x: x.f)
            best = successors[0]
            if best.f > flimit:
                return None, best.f
            if len(successors) > 1:
                alternative = successors[1].f
            else:
                alternative = np.inf
            result, best.f = RBFS(problem, best, min(flimit, alternative))
            if result is not None:
                return result, best.f

    node = Node(problem.initial)
    node.f = h(node)
    result, bestf = RBFS(problem, node, np.inf)
    return result


def hill_climbing(problem):
    """
    [Figure 4.2]
    From the initial node, keep choosing the neighbor with highest value,
    stopping when no neighbor is better.
    """
    current = Node(problem.initial)
    while True:
        neighbors = current.expand(problem)
        if not neighbors:
            break
        neighbor = argmax_random_tie(neighbors, key=lambda node: problem.value(node.state))
        if problem.value(neighbor.state) <= problem.value(current.state):
            break
        current = neighbor
    return current.state


def exp_schedule(k=20, lam=0.005, limit=100):
    """One possible schedule function for simulated annealing"""
    return lambda t: (k * np.exp(-lam * t) if t < limit else 0)


def simulated_annealing(problem, schedule=exp_schedule()):
    """[Figure 4.5] CAUTION: This differs from the pseudocode as it
    returns a state instead of a Node."""
    current = Node(problem.initial)
    for t in range(sys.maxsize):
        T = schedule(t)
        if T == 0:
            return current.state
        neighbors = current.expand(problem)
        if not neighbors:
            return current.state
        next_choice = random.choice(neighbors)
        delta_e = problem.value(next_choice.state) - problem.value(current.state)
        if delta_e > 0 or probability(np.exp(delta_e / T)):
            current = next_choice


def simulated_annealing_full(problem, schedule=exp_schedule()):
    """ This version returns all the states encountered in reaching
    the goal state."""
    states = []
    current = Node(problem.initial)
    for t in range(sys.maxsize):
        states.append(current.state)
        T = schedule(t)
        if T == 0:
            return states
        neighbors = current.expand(problem)
        if not neighbors:
            return current.state
        next_choice = random.choice(neighbors)
        delta_e = problem.value(next_choice.state) - problem.value(current.state)
        if delta_e > 0 or probability(np.exp(delta_e / T)):
            current = next_choice


def and_or_graph_search(problem):
    """[Figure 4.11]Used when the environment is nondeterministic and completely observable.
    Contains OR nodes where the agent is free to choose any action.
    After every action there is an AND node which contains all possible states
    the agent may reach due to stochastic nature of environment.
    The agent must be able to handle all possible states of the AND node (as it
    may end up in any of them).
    Returns a conditional plan to reach goal state,
    or failure if the former is not possible."""

    # functions used by and_or_search
    def or_search(state, problem, path):
        """returns a plan as a list of actions"""
        if problem.goal_test(state):
            return []
        if state in path:
            return None
        for action in problem.actions(state):
            plan = and_search(problem.result(state, action),
                              problem, path + [state, ])
            if plan is not None:
                return [action, plan]

    def and_search(states, problem, path):
        """Returns plan in form of dictionary where we take action plan[s] if we reach state s."""
        plan = {}
        for s in states:
            plan[s] = or_search(s, problem, path)
            if plan[s] is None:
                return None
        return plan

    # body of and or search
    return or_search(problem.initial, problem, [])


# Pre-defined actions for PeakFindingProblem
directions4 = {'W': (-1, 0), 'N': (0, 1), 'E': (1, 0), 'S': (0, -1)}
directions8 = dict(directions4)
directions8.update({'NW': (-1, 1), 'NE': (1, 1), 'SE': (1, -1), 'SW': (-1, -1)})


class PeakFindingProblem(Problem):
    """Problem of finding the highest peak in a limited grid"""

    def __init__(self, initial, grid, defined_actions=directions4):
        """The grid is a 2 dimensional array/list whose state is specified by tuple of indices"""
        super().__init__(initial)
        self.grid = grid
        self.defined_actions = defined_actions
        self.n = len(grid)
        assert self.n > 0
        self.m = len(grid[0])
        assert self.m > 0

    def actions(self, state):
        """Returns the list of actions which are allowed to be taken from the given state"""
        allowed_actions = []
        for action in self.defined_actions:
            next_state = vector_add(state, self.defined_actions[action])
            if 0 <= next_state[0] <= self.n - 1 and 0 <= next_state[1] <= self.m - 1:
                allowed_actions.append(action)

        return allowed_actions

    def result(self, state, action):
        """Moves in the direction specified by action"""
        return vector_add(state, self.defined_actions[action])

    def value(self, state):
        """Value of a state is the value it is the index to"""
        x, y = state
        assert 0 <= x < self.n
        assert 0 <= y < self.m
        return self.grid[x][y]


class OnlineDFSAgent:
    """
    [Figure 4.21]
    The abstract class for an OnlineDFSAgent. Override
    update_state method to convert percept to state. While initializing
    the subclass a problem needs to be provided which is an instance of
    a subclass of the Problem class.
    """

    def __init__(self, problem):
        self.problem = problem
        self.s = None
        self.a = None
        self.untried = dict()
        self.unbacktracked = dict()
        self.result = {}

    def __call__(self, percept):
        s1 = self.update_state(percept)
        if self.problem.goal_test(s1):
            self.a = None
        else:
            if s1 not in self.untried.keys():
                self.untried[s1] = self.problem.actions(s1)
            if self.s is not None:
                if s1 != self.result[(self.s, self.a)]:
                    self.result[(self.s, self.a)] = s1
                    self.unbacktracked[s1].insert(0, self.s)
            if len(self.untried[s1]) == 0:
                if len(self.unbacktracked[s1]) == 0:
                    self.a = None
                else:
                    # else a <- an action b such that result[s', b] = POP(unbacktracked[s'])
                    unbacktracked_pop = self.unbacktracked.pop(s1)
                    for (s, b) in self.result.keys():
                        if self.result[(s, b)] == unbacktracked_pop:
                            self.a = b
                            break
            else:
                self.a = self.untried.pop(s1)
        self.s = s1
        return self.a

    def update_state(self, percept):
        """To be overridden in most cases. The default case
        assumes the percept to be of type state."""
        return percept


# ______________________________________________________________________________


class OnlineSearchProblem(Problem):
    """
    A problem which is solved by an agent executing
    actions, rather than by just computation.
    Carried in a deterministic and a fully observable environment."""

    def __init__(self, initial, goal, graph):
        super().__init__(initial, goal)
        self.graph = graph

    def actions(self, state):
        return self.graph.graph_dict[state].keys()

    def output(self, state, action):
        return self.graph.graph_dict[state][action]

    def h(self, state):
        """Returns least possible cost to reach a goal for the given state."""
        return self.graph.least_costs[state]

    def c(self, s, a, s1):
        """Returns a cost estimate for an agent to move from state 's' to state 's1'."""
        return 1

    def update_state(self, percept):
        raise NotImplementedError

    def goal_test(self, state):
        if state == self.goal:
            return True
        return False


class LRTAStarAgent:
    """ [Figure 4.24]
    Abstract class for LRTA*-Agent. A problem needs to be
    provided which is an instance of a subclass of Problem Class.

    Takes a OnlineSearchProblem [Figure 4.23] as a problem.
    """

    def __init__(self, problem):
        self.problem = problem
        # self.result = {}      # no need as we are using problem.result
        self.H = {}
        self.s = None
        self.a = None

    def __call__(self, s1):  # as of now s1 is a state rather than a percept
        if self.problem.goal_test(s1):
            self.a = None
            return self.a
        else:
            if s1 not in self.H:
                self.H[s1] = self.problem.h(s1)
            if self.s is not None:
                # self.result[(self.s, self.a)] = s1    # no need as we are using problem.output

                # minimum cost for action b in problem.actions(s)
                self.H[self.s] = min(self.LRTA_cost(self.s, b, self.problem.output(self.s, b),
                                                    self.H) for b in self.problem.actions(self.s))

            # an action b in problem.actions(s1) that minimizes costs
            self.a = min(self.problem.actions(s1),
                         key=lambda b: self.LRTA_cost(s1, b, self.problem.output(s1, b), self.H))

            self.s = s1
            return self.a

    def LRTA_cost(self, s, a, s1, H):
        """Returns cost to move from state 's' to state 's1' plus
        estimated cost to get to goal from s1."""
        print(s, a, s1)
        if s1 is None:
            return self.problem.h(s)
        else:
            # sometimes we need to get H[s1] which we haven't yet added to H
            # to replace this try, except: we can initialize H with values from problem.h
            try:
                return self.problem.c(s, a, s1) + self.H[s1]
            except:
                return self.problem.c(s, a, s1) + self.problem.h(s1)


# ______________________________________________________________________________
# Genetic Algorithm


def genetic_search(problem, ngen=1000, pmut=0.1, n=20):
    """Call genetic_algorithm on the appropriate parts of a problem.
    This requires the problem to have states that can mate and mutate,
    plus a value method that scores states."""

    # NOTE: This is not tested and might not work.
    # TODO: Use this function to make Problems work with genetic_algorithm.

    s = problem.initial_state
    states = [problem.result(s, a) for a in problem.actions(s)]
    random.shuffle(states)
    return genetic_algorithm(states[:n], problem.value, ngen, pmut)


def genetic_algorithm(population, fitness_fn, gene_pool=[0, 1], f_thres=None, ngen=1000, pmut=0.1):
    """[Figure 4.8]"""
    for i in range(ngen):
        population = [mutate(recombine(*select(2, population, fitness_fn)), gene_pool, pmut)
                      for i in range(len(population))]

        fittest_individual = fitness_threshold(fitness_fn, f_thres, population)
        if fittest_individual:
            return fittest_individual

    return max(population, key=fitness_fn)


def fitness_threshold(fitness_fn, f_thres, population):
    if not f_thres:
        return None

    fittest_individual = max(population, key=fitness_fn)
    if fitness_fn(fittest_individual) >= f_thres:
        return fittest_individual

    return None


def init_population(pop_number, gene_pool, state_length):
    """Initializes population for genetic algorithm
    pop_number  :  Number of individuals in population
    gene_pool   :  List of possible values for individuals
    state_length:  The length of each individual"""
    g = len(gene_pool)
    population = []
    for i in range(pop_number):
        new_individual = [gene_pool[random.randrange(0, g)] for j in range(state_length)]
        population.append(new_individual)

    return population


def select(r, population, fitness_fn):
    fitnesses = map(fitness_fn, population)
    sampler = weighted_sampler(population, fitnesses)
    return [sampler() for i in range(r)]


def recombine(x, y):
    n = len(x)
    c = random.randrange(0, n)
    return x[:c] + y[c:]


def recombine_uniform(x, y):
    n = len(x)
    result = [0] * n
    indexes = random.sample(range(n), n)
    for i in range(n):
        ix = indexes[i]
        result[ix] = x[ix] if i < n / 2 else y[ix]

    return ''.join(str(r) for r in result)


def mutate(x, gene_pool, pmut):
    if random.uniform(0, 1) >= pmut:
        return x

    n = len(x)
    g = len(gene_pool)
    c = random.randrange(0, n)
    r = random.randrange(0, g)

    new_gene = gene_pool[r]
    return x[:c] + [new_gene] + x[c + 1:]


# _____________________________________________________________________________
# The remainder of this file implements examples for the search algorithms.

# ______________________________________________________________________________
# Graphs and Graph Problems


class Graph:
    """A graph connects nodes (vertices) by edges (links). Each edge can also
    have a length associated with it. The constructor call is something like:
        g = Graph({'A': {'B': 1, 'C': 2})
    this makes a graph with 3 nodes, A, B, and C, with an edge of length 1 from
    A to B,  and an edge of length 2 from A to C. You can also do:
        g = Graph({'A': {'B': 1, 'C': 2}, directed=False)
    This makes an undirected graph, so inverse links are also added. The graph
    stays undirected; if you add more links with g.connect('B', 'C', 3), then
    inverse link is also added. You can use g.nodes() to get a list of nodes,
    g.get('A') to get a dict of links out of A, and g.get('A', 'B') to get the
    length of the link from A to B. 'Lengths' can actually be any object at
    all, and nodes can be any hashable object."""

    def __init__(self, graph_dict=None, directed=True):
        self.graph_dict = graph_dict or {}
        self.directed = directed
        if not directed:
            self.make_undirected()

    def make_undirected(self):
        """Make a digraph into an undirected graph by adding symmetric edges."""
        for a in list(self.graph_dict.keys()):
            for (b, dist) in self.graph_dict[a].items():
                self.connect1(b, a, dist)

    def connect(self, A, B, distance=1):
        """Add a link from A and B of given distance, and also add the inverse
        link if the graph is undirected."""
        self.connect1(A, B, distance)
        if not self.directed:
            self.connect1(B, A, distance)

    def connect1(self, A, B, distance):
        """Add a link from A to B of given distance, in one direction only."""
        self.graph_dict.setdefault(A, {})[B] = distance

    def get(self, a, b=None):
        """Return a link distance or a dict of {node: distance} entries.
        .get(a,b) returns the distance or None;
        .get(a) returns a dict of {node: distance} entries, possibly {}."""
        links = self.graph_dict.setdefault(a, {})
        if b is None:
            return links
        else:
            return links.get(b)

    def nodes(self):
        """Return a list of nodes in the graph."""
        s1 = set([k for k in self.graph_dict.keys()])
        s2 = set([k2 for v in self.graph_dict.values() for k2, v2 in v.items()])
        nodes = s1.union(s2)
        return list(nodes)


def UndirectedGraph(graph_dict=None):
    """Build a Graph where every edge (including future ones) goes both ways."""
    return Graph(graph_dict=graph_dict, directed=False)


def RandomGraph(nodes=list(range(10)), min_links=2, width=400, height=300,
                curvature=lambda: random.uniform(1.1, 1.5)):
    """Construct a random graph, with the specified nodes, and random links.
    The nodes are laid out randomly on a (width x height) rectangle.
    Then each node is connected to the min_links nearest neighbors.
    Because inverse links are added, some nodes will have more connections.
    The distance between nodes is the hypotenuse times curvature(),
    where curvature() defaults to a random number between 1.1 and 1.5."""
    g = UndirectedGraph()
    g.locations = {}
    # Build the cities
    for node in nodes:
        g.locations[node] = (random.randrange(width), random.randrange(height))
    # Build roads from each city to at least min_links nearest neighbors.
    for i in range(min_links):
        for node in nodes:
            if len(g.get(node)) < min_links:
                here = g.locations[node]

                def distance_to_node(n):
                    if n is node or g.get(node, n):
                        return np.inf
                    return distance(g.locations[n], here)

                neighbor = min(nodes, key=distance_to_node)
                d = distance(g.locations[neighbor], here) * curvature()
                g.connect(node, neighbor, int(d))
    return g


""" [Figure 3.2]
Simplified road map of Romania
"""
romania_map = UndirectedGraph(dict(
    Arad=dict(Zerind=75, Sibiu=140, Timisoara=118),
    Bucharest=dict(Urziceni=85, Pitesti=101, Giurgiu=90, Fagaras=211),
    Craiova=dict(Drobeta=120, Rimnicu=146, Pitesti=138),
    Drobeta=dict(Mehadia=75),
    Eforie=dict(Hirsova=86),
    Fagaras=dict(Sibiu=99),
    Hirsova=dict(Urziceni=98),
    Iasi=dict(Vaslui=92, Neamt=87),
    Lugoj=dict(Timisoara=111, Mehadia=70),
    Oradea=dict(Zerind=71, Sibiu=151),
    Pitesti=dict(Rimnicu=97),
    Rimnicu=dict(Sibiu=80),
    Urziceni=dict(Vaslui=142)))
romania_map.locations = dict(
    Arad=(91, 492), Bucharest=(400, 327), Craiova=(253, 288),
    Drobeta=(165, 299), Eforie=(562, 293), Fagaras=(305, 449),
    Giurgiu=(375, 270), Hirsova=(534, 350), Iasi=(473, 506),
    Lugoj=(165, 379), Mehadia=(168, 339), Neamt=(406, 537),
    Oradea=(131, 571), Pitesti=(320, 368), Rimnicu=(233, 410),
    Sibiu=(207, 457), Timisoara=(94, 410), Urziceni=(456, 350),
    Vaslui=(509, 444), Zerind=(108, 531))

""" [Figure 4.9]
Eight possible states of the vacumm world
Each state is represented as
   *       "State of the left room"      "State of the right room"   "Room in which the agent
                                                                      is present"
1 - DDL     Dirty                         Dirty                       Left
2 - DDR     Dirty                         Dirty                       Right
3 - DCL     Dirty                         Clean                       Left
4 - DCR     Dirty                         Clean                       Right
5 - CDL     Clean                         Dirty                       Left
6 - CDR     Clean                         Dirty                       Right
7 - CCL     Clean                         Clean                       Left
8 - CCR     Clean                         Clean                       Right
"""
vacuum_world = Graph(dict(
    State_1=dict(Suck=['State_7', 'State_5'], Right=['State_2']),
    State_2=dict(Suck=['State_8', 'State_4'], Left=['State_2']),
    State_3=dict(Suck=['State_7'], Right=['State_4']),
    State_4=dict(Suck=['State_4', 'State_2'], Left=['State_3']),
    State_5=dict(Suck=['State_5', 'State_1'], Right=['State_6']),
    State_6=dict(Suck=['State_8'], Left=['State_5']),
    State_7=dict(Suck=['State_7', 'State_3'], Right=['State_8']),
    State_8=dict(Suck=['State_8', 'State_6'], Left=['State_7'])
))

""" [Figure 4.23]
One-dimensional state space Graph
"""
one_dim_state_space = Graph(dict(
    State_1=dict(Right='State_2'),
    State_2=dict(Right='State_3', Left='State_1'),
    State_3=dict(Right='State_4', Left='State_2'),
    State_4=dict(Right='State_5', Left='State_3'),
    State_5=dict(Right='State_6', Left='State_4'),
    State_6=dict(Left='State_5')
))
one_dim_state_space.least_costs = dict(
    State_1=8,
    State_2=9,
    State_3=2,
    State_4=2,
    State_5=4,
    State_6=3)

""" [Figure 6.1]
Principal states and territories of Australia
"""
australia_map = UndirectedGraph(dict(
    T=dict(),
    SA=dict(WA=1, NT=1, Q=1, NSW=1, V=1),
    NT=dict(WA=1, Q=1),
    NSW=dict(Q=1, V=1)))
australia_map.locations = dict(WA=(120, 24), NT=(135, 20), SA=(135, 30),
                               Q=(145, 20), NSW=(145, 32), T=(145, 42),
                               V=(145, 37))


class GraphProblem(Problem):
    """The problem of searching a graph from one node to another."""

    def __init__(self, initial, goal, graph):
        super().__init__(initial, goal)
        self.graph = graph

    def actions(self, A):
        """The actions at a graph node are just its neighbors."""
        return list(self.graph.get(A).keys())

    def result(self, state, action):
        """The result of going to a neighbor is just that neighbor."""
        return action

    def path_cost(self, cost_so_far, A, action, B):
        return cost_so_far + (self.graph.get(A, B) or np.inf)

    def find_min_edge(self):
        """Find minimum value of edges."""
        m = np.inf
        for d in self.graph.graph_dict.values():
            local_min = min(d.values())
            m = min(m, local_min)

        return m

    def h(self, node):
        """h function is straight-line distance from a node's state to goal."""
        locs = getattr(self.graph, 'locations', None)
        if locs:
            if type(node) is str:
                return int(distance(locs[node], locs[self.goal]))

            return int(distance(locs[node.state], locs[self.goal]))
        else:
            return np.inf


class GraphProblemStochastic(GraphProblem):
    """
    A version of GraphProblem where an action can lead to
    nondeterministic output i.e. multiple possible states.

    Define the graph as dict(A = dict(Action = [[<Result 1>, <Result 2>, ...], <cost>], ...), ...)
    A the dictionary format is different, make sure the graph is created as a directed graph.
    """

    def result(self, state, action):
        return self.graph.get(state, action)

    def path_cost(self):
        raise NotImplementedError


# ______________________________________________________________________________


class NQueensProblem(Problem):
    """The problem of placing N queens on an NxN board with none attacking
    each other. A state is represented as an N-element array, where
    a value of r in the c-th entry means there is a queen at column c,
    row r, and a value of -1 means that the c-th column has not been
    filled in yet. We fill in columns left to right.
    >>> depth_first_tree_search(NQueensProblem(8))
    <Node (7, 3, 0, 2, 5, 1, 6, 4)>
    """

    def __init__(self, N):
        super().__init__(tuple([-1] * N))
        self.N = N

    def actions(self, state):
        """In the leftmost empty column, try all non-conflicting rows."""
        if state[-1] != -1:
            return []  # All columns filled; no successors
        else:
            col = state.index(-1)
            return [row for row in range(self.N)
                    if not self.conflicted(state, row, col)]

    def result(self, state, row):
        """Place the next queen at the given row."""
        col = state.index(-1)
        new = list(state[:])
        new[col] = row
        return tuple(new)

    def conflicted(self, state, row, col):
        """Would placing a queen at (row, col) conflict with anything?"""
        return any(self.conflict(row, col, state[c], c)
                   for c in range(col))

    def conflict(self, row1, col1, row2, col2):
        """Would putting two queens in (row1, col1) and (row2, col2) conflict?"""
        return (row1 == row2 or  # same row
                col1 == col2 or  # same column
                row1 - col1 == row2 - col2 or  # same \ diagonal
                row1 + col1 == row2 + col2)  # same / diagonal

    def goal_test(self, state):
        """Check if all columns filled, no conflicts."""
        if state[-1] == -1:
            return False
        return not any(self.conflicted(state, state[col], col)
                       for col in range(len(state)))

    def h(self, node):
        """Return number of conflicting queens for a given node"""
        num_conflicts = 0
        for (r1, c1) in enumerate(node.state):
            for (r2, c2) in enumerate(node.state):
                if (r1, c1) != (r2, c2):
                    num_conflicts += self.conflict(r1, c1, r2, c2)

        return num_conflicts


# ______________________________________________________________________________
# Inverse Boggle: Search for a high-scoring Boggle board. A good domain for
# iterative-repair and related search techniques, as suggested by Justin Boyan.


ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

cubes16 = ['FORIXB', 'MOQABJ', 'GURILW', 'SETUPL',
           'CMPDAE', 'ACITAO', 'SLCRAE', 'ROMASH',
           'NODESW', 'HEFIYE', 'ONUDTK', 'TEVIGN',
           'ANEDVZ', 'PINESH', 'ABILYT', 'GKYLEU']


def random_boggle(n=4):
    """Return a random Boggle board of size n x n.
    We represent a board as a linear list of letters."""
    cubes = [cubes16[i % 16] for i in range(n * n)]
    random.shuffle(cubes)
    return list(map(random.choice, cubes))


# The best 5x5 board found by Boyan, with our word list this board scores
# 2274 words, for a score of 9837


boyan_best = list('RSTCSDEIAEGNLRPEATESMSSID')


def print_boggle(board):
    """Print the board in a 2-d array."""
    n2 = len(board)
    n = exact_sqrt(n2)
    for i in range(n2):

        if i % n == 0 and i > 0:
            print()
        if board[i] == 'Q':
            print('Qu')
        else:
            print(str(board[i]) + ' ')
    print()


def boggle_neighbors(n2, cache={}):
    """Return a list of lists, where the i-th element is the list of indexes
    for the neighbors of square i."""
    if cache.get(n2):
        return cache.get(n2)
    n = exact_sqrt(n2)
    neighbors = [None] * n2
    for i in range(n2):
        neighbors[i] = []
        on_top = i < n
        on_bottom = i >= n2 - n
        on_left = i % n == 0
        on_right = (i + 1) % n == 0
        if not on_top:
            neighbors[i].append(i - n)
            if not on_left:
                neighbors[i].append(i - n - 1)
            if not on_right:
                neighbors[i].append(i - n + 1)
        if not on_bottom:
            neighbors[i].append(i + n)
            if not on_left:
                neighbors[i].append(i + n - 1)
            if not on_right:
                neighbors[i].append(i + n + 1)
        if not on_left:
            neighbors[i].append(i - 1)
        if not on_right:
            neighbors[i].append(i + 1)
    cache[n2] = neighbors
    return neighbors


def exact_sqrt(n2):
    """If n2 is a perfect square, return its square root, else raise error."""
    n = int(np.sqrt(n2))
    assert n * n == n2
    return n


# _____________________________________________________________________________


class Wordlist:
    """This class holds a list of words. You can use (word in wordlist)
    to check if a word is in the list, or wordlist.lookup(prefix)
    to see if prefix starts any of the words in the list."""

    def __init__(self, file, min_len=3):
        lines = file.read().upper().split()
        self.words = [word for word in lines if len(word) >= min_len]
        self.words.sort()
        self.bounds = {}
        for c in ALPHABET:
            c2 = chr(ord(c) + 1)
            self.bounds[c] = (bisect.bisect(self.words, c),
                              bisect.bisect(self.words, c2))

    def lookup(self, prefix, lo=0, hi=None):
        """See if prefix is in dictionary, as a full word or as a prefix.
        Return two values: the first is the lowest i such that
        words[i].startswith(prefix), or is None; the second is
        True iff prefix itself is in the Wordlist."""
        words = self.words
        if hi is None:
            hi = len(words)
        i = bisect.bisect_left(words, prefix, lo, hi)
        if i < len(words) and words[i].startswith(prefix):
            return i, (words[i] == prefix)
        else:
            return None, False

    def __contains__(self, word):
        return self.lookup(word)[1]

    def __len__(self):
        return len(self.words)


# _____________________________________________________________________________


class BoggleFinder:
    """A class that allows you to find all the words in a Boggle board."""

    wordlist = None  # A class variable, holding a wordlist

    def __init__(self, board=None):
        if BoggleFinder.wordlist is None:
            BoggleFinder.wordlist = Wordlist(open_data("EN-text/wordlist.txt"))
        self.found = {}
        if board:
            self.set_board(board)

    def set_board(self, board=None):
        """Set the board, and find all the words in it."""
        if board is None:
            board = random_boggle()
        self.board = board
        self.neighbors = boggle_neighbors(len(board))
        self.found = {}
        for i in range(len(board)):
            lo, hi = self.wordlist.bounds[board[i]]
            self.find(lo, hi, i, [], '')
        return self

    def find(self, lo, hi, i, visited, prefix):
        """Looking in square i, find the words that continue the prefix,
        considering the entries in self.wordlist.words[lo:hi], and not
        revisiting the squares in visited."""
        if i in visited:
            return
        wordpos, is_word = self.wordlist.lookup(prefix, lo, hi)
        if wordpos is not None:
            if is_word:
                self.found[prefix] = True
            visited.append(i)
            c = self.board[i]
            if c == 'Q':
                c = 'QU'
            prefix += c
            for j in self.neighbors[i]:
                self.find(wordpos, hi, j, visited, prefix)
            visited.pop()

    def words(self):
        """The words found."""
        return list(self.found.keys())

    scores = [0, 0, 0, 0, 1, 2, 3, 5] + [11] * 100

    def score(self):
        """The total score for the words found, according to the rules."""
        return sum([self.scores[len(w)] for w in self.words()])

    def __len__(self):
        """The number of words found."""
        return len(self.found)


# _____________________________________________________________________________


def boggle_hill_climbing(board=None, ntimes=100, verbose=True):
    """Solve inverse Boggle by hill-climbing: find a high-scoring board by
    starting with a random one and changing it."""
    finder = BoggleFinder()
    if board is None:
        board = random_boggle()
    best = len(finder.set_board(board))
    for _ in range(ntimes):
        i, oldc = mutate_boggle(board)
        new = len(finder.set_board(board))
        if new > best:
            best = new
            if verbose:
                print(best, _, board)
        else:
            board[i] = oldc  # Change back
    if verbose:
        print_boggle(board)
    return board, best


def mutate_boggle(board):
    i = random.randrange(len(board))
    oldc = board[i]
    # random.choice(boyan_best)
    board[i] = random.choice(random.choice(cubes16))
    return i, oldc


# ______________________________________________________________________________

# Code to compare searchers on various problems.


class InstrumentedProblem(Problem):
    """Delegates to a problem, and keeps statistics."""

    def __init__(self, problem):
        self.problem = problem
        self.succs = self.goal_tests = self.states = 0
        self.found = None

    def actions(self, state):
        self.succs += 1
        return self.problem.actions(state)

    def result(self, state, action):
        self.states += 1
        return self.problem.result(state, action)

    def goal_test(self, state):
        self.goal_tests += 1
        result = self.problem.goal_test(state)
        if result:
            self.found = state
        return result

    def path_cost(self, c, state1, action, state2):
        return self.problem.path_cost(c, state1, action, state2)

    def value(self, state):
        return self.problem.value(state)

    def __getattr__(self, attr):
        return getattr(self.problem, attr)

    def __repr__(self):
        return '<{:4d}/{:4d}/{:4d}/{}>'.format(self.succs, self.goal_tests,
                                               self.states, str(self.found)[:4])


def compare_searchers(problems, header,
                      searchers=[breadth_first_tree_search,
                                 breadth_first_graph_search,
                                 depth_first_graph_search,
                                 iterative_deepening_search,
                                 depth_limited_search,
                                 recursive_best_first_search]):
    def do(searcher, problem):
        p = InstrumentedProblem(problem)
        searcher(p)
        return p

    table = [[name(s)] + [do(s, p) for p in problems] for s in searchers]
    print_table(table, header)


def compare_graph_searchers():
    """Prints a table of search results."""
    compare_searchers(problems=[GraphProblem('Arad', 'Bucharest', romania_map),
                                GraphProblem('Oradea', 'Neamt', romania_map),
                                GraphProblem('Q', 'WA', australia_map)],
                      header=['Searcher', 'romania_map(Arad, Bucharest)',
                              'romania_map(Oradea, Neamt)', 'australia_map'])]]>
                </content>
              </script>
              <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
              <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
              <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
              <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
            </Box>
            <Box name="A" id="3" localization="8" tooltip="" x="197" y="14">
              <bitmap>media/images/box/box-python-script.png</bitmap>
              <script language="4">
                <content>
                  <![CDATA[

def h(node):
    snap, star, wave, exp, hide, ymca, fist, time, goal = node.state
    return goal - time


SNAP, STAR, WAVE, EXP, HIDE, YMCA, FIST, PAUSE = range(8)
TIMES = [676, 360, 700, 408, 500, 936, 576, 1]

class A(Problem):
    def value(self, state):
        pass

    def result(self, state, action):
        snap, star, wave, exp, hide, ymca, fist, time, goal = state
        index = PAUSE
        if 'snap' in action:
            snap = 1 - snap
            index = SNAP
        if 'star' in action:
            star = 1 - star
            index = STAR
        if 'wave' in action:
            wave = 1 - wave
            index = WAVE
        if 'exp' in action:
            exp = 1 - exp
            index = EXP
        if 'hide' in action:
            hide = 1 - hide
            index = HIDE
        if 'ymca' in action:
            ymca = 1 - ymca
            index = YMCA
        if 'fist' in action:
            fist = 1 - fist
            index = FIST
        if 'pause' in action:
            index = PAUSE
        time += TIMES[index]
        return snap, star, wave, exp, hide, ymca, fist, time, goal

    def actions(self, state):
        snap, star, wave, exp, hide, ymca, fist, time, goal = state
        result = ['pause']
        if snap and time + TIMES[SNAP] <= goal:
            result.append('snap')
        if star and time + TIMES[STAR] <= goal:
            result.append('star')
        if wave and time + TIMES[WAVE] <= goal:
            result.append('wave')
        if exp and time + TIMES[EXP] <= goal:
            result.append('exp')
        if hide and time + TIMES[HIDE] <= goal:
            result.append('hide')
        if ymca and time + TIMES[YMCA] <= goal:
            result.append('ymca')
        if fist and time + TIMES[FIST] <= goal:
            result.append('fist')
        return result

    def path_cost(self, c, state1, action, state2):
        if 'pause' in action:
            return c+1
        else:
            return c

    def goal_test(self, state):
        snap, star, wave, exp, hide, ymca, fist, time, goal = state
        if time == goal:
            return True
        else:
            return False]]>
                </content>
              </script>
              <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
              <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
              <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
              <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
            </Box>
            <Box name="main" id="4" localization="8" tooltip="" x="427" y="206">
              <bitmap>media/images/box/box-python-script.png</bitmap>
              <script language="4">
                <content>
                  <![CDATA[from collections import defaultdict, deque, Counter
import math
import time

failure = Node('failure', path_cost=float('inf')) # Indicates an algorithm couldn't find a solution.
cutoff  = Node('cutoff',  path_cost=float('inf')) # Indicates iterative deepening search was cut off.


def path_actions(node):
    """The sequence of actions to get to this node."""
    if node is None:
        return []
    if node.parent is None:
        return []
    return path_actions(node.parent) + [node.action]


def path_states(node):
    """The sequence of states to get to this node."""
    if node in (cutoff, failure, None):
        return []
    return path_states(node.parent) + [node.state]


class CountCalls:
    """Delegate all attribute gets to the object, and count them in ._counts"""

    def __init__(self, obj):
        self._object = obj
        self._counts = Counter()

    def __getattr__(self, attr):
        "Delegate to the original object, after incrementing a counter."
        self._counts[attr] += 1
        return getattr(self._object, attr)

def myLen(node):
    return 0 if node.parent is None else (1 + myLen(node.parent))

def report(searchers, problems, verbose=True):
    """Show summary statistics for each searcher (and on each problem unless verbose is false)."""
    for searcher in searchers:
        print(searcher.__name__ + ':')
        total_counts = Counter()
        for p in problems:
            prob = CountCalls(p)
            soln = searcher(prob)
            counts = prob._counts;
            counts.update(actions=myLen(soln), cost=soln.path_cost)
            total_counts += counts
            if verbose: report_counts(counts, str(p)[:40])
        report_counts(total_counts, 'TOTAL\n')


def report_counts(counts, name):
    """Print one line of the counts report."""
    print('{:9,d} nodes |{:9,d} goal |{:5.0f} cost |{:8,d} actions | {}'.format(
        counts['result'], counts['is_goal'], counts['cost'], counts['actions'], name))



###########################################################################################################

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        MANDATORY_TIME = [3500, 1800, 1500, 1200, 1400, 1600, 1400, 1500]
        MANDATORY_POS = ["technologic", "stand","wideForehead","hello", "standZero", "sit", "sitRelax", "crouch"]
        MANDATORY_DURATION = [0,0,0,0,0,0,0,0] #First must be 0, the other ones must be the duration in cs of the precedent mandatory
        self.path = []
        for time, pos, dur in zip(MANDATORY_TIME, MANDATORY_POS, MANDATORY_DURATION):
            problem = A((1, 1, 1, 1, 1, 1, 1, dur, time))
            solution = breadth_first_graph_search(problem)
            path = path_actions(solution)
            n_pauses = path.count("pause")
            n_moves = len(path) - n_pauses
            path = list(filter(lambda x: x != "pause", path))
            new_path = []
            if n_pauses % n_moves != 0:
                mod = n_pauses % n_moves
            else:
                mod = 0
            for i in range(n_moves+1):
                new_path.extend(["pause"] * ((n_pauses // n_moves) + mod))
                if i != (n_moves):
                    new_path.append(path.pop())
                mod = 0
            self.logger.info(new_path)
            cost = solution.path_cost
            self.logger.info('cost = {}'.format(cost))
            self.path.extend(new_path)
            self.path.append(pos)

    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        mvm = Moves()
        mvm.initial()
        time.sleep(0.2)
        for move in self.path:
            if move == "pause":
                time.sleep(0.01)
            if move == "fist":
                mvm.fist()
            if move== 'ymca':
                mvm.ymca()
            if move == 'wave':
                mvm.wave()
            if move == 'star':
                mvm.star()
            if move == 'snap':
                mvm.snap()
            if move == 'hide':
                mvm.hide()
            if move == 'exp':
                mvm.exp()
            if move == 'stand':
                mvm.stand()
            if move == 'standInit':
                mvm.initial()
            if move == 'standZero':
                mvm.standZero()
            if move == 'crouch':
                mvm.crouch()
            if move == 'sit':
                mvm.sit()
            if move == 'sitRelax':
                mvm.sitRelax()
            if move == 'technologic':
                mvm.technologic()
            if move == 'wideForehead':
                mvm.wideForehead()
            if move == 'hello':
                mvm.hello()


    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
                </content>
              </script>
              <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
              <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
              <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
              <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
            </Box>
            <Box name="reporting" id="5" localization="8" tooltip="" x="309" y="10">
              <bitmap>media/images/box/box-python-script.png</bitmap>
              <script language="4">
                <content>
                  <![CDATA[]]>
                </content>
              </script>
              <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
              <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
              <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
              <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
            </Box>
            <Box name="moves" id="6" localization="8" tooltip="" x="666" y="18">
              <bitmap>media/images/box/box-python-script.png</bitmap>
              <script language="4">
                <content>
                  <![CDATA[class Moves:
    def __init__(self):
        # Choregraphe bezier export in Python.
        pass
    def onLoad(self):
        pass
    def onUnload(self):
        #put clean-up code here
        pass
    def onInput_onStart(self):
        pass
    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box
################################################################################################################################################################################################################################################################################################################################################################################################
    def initial(self):
        names = list()
        times = list()
        keys = list()

        names.append("HeadPitch")
        times.append([0.4])
        keys.append([0])

        names.append("HeadYaw")
        times.append([0.4])
        keys.append([0])

        names.append("LAnklePitch")
        times.append([0.4])
        keys.append([-0.343155])

        names.append("LAnkleRoll")
        times.append([0.4])
        keys.append([-0.00657455])

        names.append("LElbowRoll")
        times.append([0.4])
        keys.append([-1.00616])

        names.append("LElbowYaw")
        times.append([0.4])
        keys.append([-1.38505])

        names.append("LHand")
        times.append([0.4])
        keys.append([0.252967])

        names.append("LHipPitch")
        times.append([0.4])
        keys.append([-0.440965])

        names.append("LHipRoll")
        times.append([0.4])
        keys.append([0.00186381])

        names.append("LHipYawPitch")
        times.append([0.4])
        keys.append([0])

        names.append("LKneePitch")
        times.append([0.4])
        keys.append([0.7])

        names.append("LShoulderPitch")
        times.append([0.4])
        keys.append([1.40597])

        names.append("LShoulderRoll")
        times.append([0.4])
        keys.append([0.29113])

        names.append("LWristYaw")
        times.append([0.4])
        keys.append([0.00472956])

        names.append("RAnklePitch")
        times.append([0.4])
        keys.append([-0.343155])

        names.append("RAnkleRoll")
        times.append([0.4])
        keys.append([0.0065743])

        names.append("RElbowRoll")
        times.append([0.4])
        keys.append([1.00616])

        names.append("RElbowYaw")
        times.append([0.4])
        keys.append([1.38505])

        names.append("RHand")
        times.append([0.4])
        keys.append([0.252967])

        names.append("RHipPitch")
        times.append([0.4])
        keys.append([-0.440965])

        names.append("RHipRoll")
        times.append([0.4])
        keys.append([-0.00186372])

        names.append("RHipYawPitch")
        times.append([0.4])
        keys.append([0])

        names.append("RKneePitch")
        times.append([0.4])
        keys.append([0.7])

        names.append("RShoulderPitch")
        times.append([0.4])
        keys.append([1.40597])

        names.append("RShoulderRoll")
        times.append([0.4])
        keys.append([-0.29113])

        names.append("RWristYaw")
        times.append([0.4])
        keys.append([0.00472956])

        try:
          # uncomment the following line and modify the IP if you use this script outside Choregraphe.
          # motion = ALProxy("ALMotion", IP, 9559)
          motion = ALProxy("ALMotion")
          motion.angleInterpolation(names, keys, times, True)
        except BaseException, err:
          print err

    def wideForehead(self):
            names = list()
            times = list()
            keys = list()

            names.append("HeadPitch")
            times.append([0.28, 0.96])
            keys.append([0.509465, -0.591705])

            names.append("HeadYaw")
            times.append([0.28])
            keys.append([0])

            names.append("LAnklePitch")
            times.append([0.28])
            keys.append([0.0866826])

            names.append("LAnkleRoll")
            times.append([0.28])
            keys.append([-0.100801])

            names.append("LElbowRoll")
            times.append([0.28])
            keys.append([-0.423237])

            names.append("LElbowYaw")
            times.append([0.28])
            keys.append([-1.20177])

            names.append("LHand")
            times.append([0.28])
            keys.append([0.291937])

            names.append("LHipPitch")
            times.append([0.28])
            keys.append([0.123171])

            names.append("LHipRoll")
            times.append([0.28])
            keys.append([0.115137])

            names.append("LHipYawPitch")
            times.append([0.28])
            keys.append([-0.171605])

            names.append("LKneePitch")
            times.append([0.28])
            keys.append([-0.0872552])

            names.append("LShoulderPitch")
            times.append([0.28])
            keys.append([1.43705])

            names.append("LShoulderRoll")
            times.append([0.28])
            keys.append([0.223632])

            names.append("LWristYaw")
            times.append([0.28])
            keys.append([0.102824])

            names.append("RAnklePitch")
            times.append([0.28])
            keys.append([0.0866825])

            names.append("RAnkleRoll")
            times.append([0.28])
            keys.append([0.100797])

            names.append("RElbowRoll")
            times.append([0.28])
            keys.append([0.423237])

            names.append("RElbowYaw")
            times.append([0.28])
            keys.append([1.20177])

            names.append("RHand")
            times.append([0.28])
            keys.append([0.291937])

            names.append("RHipPitch")
            times.append([0.28])
            keys.append([0.123172])

            names.append("RHipRoll")
            times.append([0.28])
            keys.append([-0.115132])

            names.append("RHipYawPitch")
            times.append([0.28])
            keys.append([-0.171605])

            names.append("RKneePitch")
            times.append([0.28])
            keys.append([-0.0872552])

            names.append("RShoulderPitch")
            times.append([0.28])
            keys.append([1.43705])

            names.append("RShoulderRoll")
            times.append([0.28])
            keys.append([-0.223631])

            names.append("RWristYaw")
            times.append([0.28])
            keys.append([0.0943753])

            try:
              # uncomment the following line and modify the IP if you use this script outside Choregraphe.
              # motion = ALProxy("ALMotion", IP, 9559)
              motion = ALProxy("ALMotion")
              motion.angleInterpolation(names, keys, times, True)
            except BaseException, err:
              print err

    def ymca(self):
        names = list()
        times = list()
        keys = list()
        names.append("HeadPitch")
        times.append([0.96, 1.68, 2.08, 2.68, 3.8, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[0.386526, [3, -0.333333, 0], [3, 0.24, 0]], [-0.0453786, [3, -0.24, 0], [3, 0.133333, 0]], [0.228638, [3, -0.133333, 0], [3, 0.2, 0]], [-0.06447, [3, -0.2, 0.00739602], [3, 0.373333, -0.0138059]], [-0.0782759, [3, -0.373333, 0.0138059], [3, 0.64, -0.0236673]], [-0.20253, [3, -0.64, 0], [3, 0.16, 0]], [0.386526, [3, -0.16, 0], [3, 0.24, 0]], [-0.0453786, [3, -0.24, 0], [3, 0.133333, 0]], [0.228638, [3, -0.133333, 0], [3, 0.2, 0]], [-0.06447, [3, -0.2, 0], [3, 0.173333, 0]], [0.110406, [3, -0.173333, 0], [3, 0.24, 0]], [-0.326783, [3, -0.24, 0], [3, 0, 0]]])
        names.append("HeadYaw")
        times.append([0.96, 1.68, 2.08, 2.68, 3.8, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[-0.16418, [3, -0.333333, 0], [3, 0.24, 0]], [-0.161112, [3, -0.24, -0.00306794], [3, 0.133333, 0.00170441]], [-0.14884, [3, -0.133333, 0], [3, 0.2, 0]], [-0.153442, [3, -0.2, 0.00460209], [3, 0.373333, -0.00859057]], [-0.865134, [3, -0.373333, 0], [3, 0.64, 0]], [0.130432, [3, -0.64, -0.134992], [3, 0.16, 0.033748]], [0.16418, [3, -0.16, 0], [3, 0.24, 0]], [0.161112, [3, -0.24, 0.00306794], [3, 0.133333, -0.00170441]], [0.14884, [3, -0.133333, 0], [3, 0.2, 0]], [0.153442, [3, -0.2, 0], [3, 0.173333, 0]], [-0.029188, [3, -0.173333, 0], [3, 0.24, 0]], [-0.0245859, [3, -0.24, 0], [3, 0, 0]]])
        names.append("LAnklePitch")
        times.append([0.96, 1.68, 2.68, 3.16, 3.8, 4.04, 4.28, 4.76, 5.24, 5.72, 6.2, 6.92, 7.92, 9.16])
        keys.append([[-0.0353239, [3, -0.333333, 0], [3, 0.24, 0]], [0.0551821, [3, -0.24, -0.0248294], [3, 0.333333, 0.0344853]], [0.14262, [3, -0.333333, 0], [3, 0.16, 0]], [-0.0245859, [3, -0.16, 0], [3, 0.213333, 0]], [0.00523599, [3, -0.213333, 0], [3, 0.08, 0]], [-0.00174533, [3, -0.08, 0], [3, 0.08, 0]], [0.0314159, [3, -0.08, 0], [3, 0.16, 0]], [0.0314159, [3, -0.16, 0], [3, 0.16, 0]], [0.0314159, [3, -0.16, 0], [3, 0.16, 0]], [0.0122173, [3, -0.16, 0], [3, 0.16, 0]], [0.04913, [3, -0.16, 0], [3, 0.24, 0]], [-0.16418, [3, -0.24, 0.0131932], [3, 0.333333, -0.0183239]], [-0.182504, [3, -0.333333, 0], [3, 0.413333, 0]], [-0.0614019, [3, -0.413333, 0], [3, 0, 0]]])
        names.append("LAnkleRoll")
        times.append([0.96, 1.68, 2.68, 3.16, 3.8, 4.28, 4.76, 5.24, 5.72, 6.2, 6.92, 7.92, 9.16])
        keys.append([[-0.205514, [3, -0.333333, 0], [3, 0.24, 0]], [0.122762, [3, -0.24, 0], [3, 0.333333, 0]], [-0.0720561, [3, -0.333333, 0], [3, 0.16, 0]], [0.158044, [3, -0.16, -0.00451276], [3, 0.213333, 0.00601701]], [0.164061, [3, -0.213333, 0], [3, 0.16, 0]], [0.164061, [3, -0.16, 0], [3, 0.16, 0]], [0.164061, [3, -0.16, 0], [3, 0.16, 0]], [0.164061, [3, -0.16, 0], [3, 0.16, 0]], [0.162562, [3, -0.16, 0.000761137], [3, 0.16, -0.000761137]], [0.159494, [3, -0.16, 0.00306794], [3, 0.24, -0.00460192]], [-0.246933, [3, -0.24, 0], [3, 0.333333, 0]], [0.00456004, [3, -0.333333, 0], [3, 0.413333, 0]], [-0.0827941, [3, -0.413333, 0], [3, 0, 0]]])
        names.append("LElbowRoll")
        times.append([0.96, 1.68, 2.08, 2.68, 3.16, 3.8, 4.76, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[-1.50481, [3, -0.333333, 0], [3, 0.24, 0]], [-1.54462, [3, -0.24, 0], [3, 0.133333, 0]], [-1.50481, [3, -0.133333, 0], [3, 0.2, 0]], [-1.50635, [3, -0.2, 0], [3, 0.16, 0]], [-0.752237, [3, -0.16, 0], [3, 0.213333, 0]], [-1.25179, [3, -0.213333, 0], [3, 0.32, 0]], [-0.0349066, [3, -0.32, 0], [3, 0.32, 0]], [-0.0349066, [3, -0.32, 0], [3, 0.16, 0]], [-1.54462, [3, -0.16, 0], [3, 0.24, 0]], [-0.248551, [3, -0.24, 0], [3, 0.133333, 0]], [-1.54462, [3, -0.133333, 0], [3, 0.2, 0]], [-0.0349066, [3, -0.2, 0], [3, 0.173333, 0]], [-1.38056, [3, -0.173333, 0.0742293], [3, 0.24, -0.102779]], [-1.48334, [3, -0.24, 0], [3, 0, 0]]])
        names.append("LElbowYaw")
        times.append([0.96, 1.68, 2.08, 2.68, 3.8, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[0.0628521, [3, -0.333333, 0], [3, 0.24, 0]], [0.061318, [3, -0.24, 0], [3, 0.133333, 0]], [0.0628521, [3, -0.133333, -0.000613612], [3, 0.2, 0.000920418]], [0.06592, [3, -0.2, 0], [3, 0.373333, 0]], [-0.0475121, [3, -0.373333, 0], [3, 0.64, 0]], [0.0541052, [3, -0.64, 0], [3, 0.16, 0]], [-1.51095, [3, -0.16, 0], [3, 0.24, 0]], [0.158044, [3, -0.24, 0], [3, 0.133333, 0]], [-1.51095, [3, -0.133333, 0], [3, 0.2, 0]], [-0.084328, [3, -0.2, 0], [3, 0.173333, 0]], [-0.142704, [3, -0.173333, 0.0583759], [3, 0.24, -0.0808281]], [-0.768577, [3, -0.24, 0], [3, 0, 0]]])
        names.append("LHand")
        times.append([0.96, 1.68, 2.08, 2.68, 3.8, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[0.8264, [3, -0.333333, 0], [3, 0.24, 0]], [0.8276, [3, -0.24, 0], [3, 0.133333, 0]], [0.8264, [3, -0.133333, 0], [3, 0.2, 0]], [0.828, [3, -0.2, -0.00160003], [3, 0.373333, 0.00298672]], [0.9552, [3, -0.373333, 0], [3, 0.64, 0]], [0.9524, [3, -0.64, 0.00279999], [3, 0.16, -0.000699997]], [0.0512, [3, -0.16, 0.00346667], [3, 0.24, -0.0052]], [0.046, [3, -0.24, 0], [3, 0.133333, 0]], [0.0512, [3, -0.133333, -0.000266669], [3, 0.2, 0.000400003]], [0.0516, [3, -0.2, -0.000400003], [3, 0.173333, 0.000346669]], [0.3384, [3, -0.173333, 0], [3, 0.24, 0]], [0, [3, -0.24, 0], [3, 0, 0]]])
        names.append("LHipPitch")
        times.append([0.96, 1.68, 2.68, 3.16, 3.8, 4.28, 4.76, 5.24, 5.72, 6.2, 6.92, 7.92, 9.16])
        keys.append([[-0.151824, [3, -0.333333, 0], [3, 0.24, 0]], [0.340591, [3, -0.24, 0], [3, 0.333333, 0]], [0.248551, [3, -0.333333, 0], [3, 0.16, 0]], [0.415757, [3, -0.16, 0], [3, 0.213333, 0]], [0.220854, [3, -0.213333, 0], [3, 0.16, 0]], [0.220854, [3, -0.16, 0], [3, 0.16, 0]], [0.220854, [3, -0.16, 0], [3, 0.16, 0]], [0.220854, [3, -0.16, 0], [3, 0.16, 0]], [0.21932, [3, -0.16, 0], [3, 0.16, 0]], [0.223922, [3, -0.16, 0], [3, 0.24, 0]], [0.16418, [3, -0.24, 0], [3, 0.333333, 0]], [0.174835, [3, -0.333333, -0.00319582], [3, 0.413333, 0.00396282]], [0.185656, [3, -0.413333, 0], [3, 0, 0]]])
        names.append("LHipRoll")
        times.append([0.96, 1.68, 2.68, 3.16, 3.8, 4.28, 4.76, 5.24, 5.72, 6.2, 6.92, 7.92, 9.16])
        keys.append([[0.274628, [3, -0.333333, 0], [3, 0.24, 0]], [-0.159494, [3, -0.24, 0], [3, 0.333333, 0]], [0.105888, [3, -0.333333, 0], [3, 0.16, 0]], [-0.191709, [3, -0.16, 0], [3, 0.213333, 0]], [-0.067538, [3, -0.213333, 0], [3, 0.16, 0]], [-0.067538, [3, -0.16, 0], [3, 0.16, 0]], [-0.067538, [3, -0.16, 0], [3, 0.16, 0]], [-0.067538, [3, -0.16, 0], [3, 0.16, 0]], [-0.0690719, [3, -0.16, 0.00153397], [3, 0.16, -0.00153397]], [-0.233209, [3, -0.16, 0], [3, 0.24, 0]], [0.352862, [3, -0.24, 0], [3, 0.333333, 0]], [0.0551821, [3, -0.333333, 0], [3, 0.413333, 0]], [0.0859459, [3, -0.413333, 0], [3, 0, 0]]])
        names.append("LHipYawPitch")
        times.append([0.96, 1.68, 2.68, 3.16, 3.8, 4.28, 4.76, 5.24, 5.72, 6.2, 6.92, 7.92, 9.16])
        keys.append([[-0.450955, [3, -0.333333, 0], [3, 0.24, 0]], [-0.510779, [3, -0.24, 0], [3, 0.333333, 0]], [-0.49544, [3, -0.333333, -0.0153397], [3, 0.16, 0.00736304]], [-0.332836, [3, -0.16, 0], [3, 0.213333, 0]], [-0.438078, [3, -0.213333, 0.039738], [3, 0.16, -0.0298035]], [-0.54146, [3, -0.16, 0], [3, 0.16, 0]], [-0.54146, [3, -0.16, 0], [3, 0.16, 0]], [-0.54146, [3, -0.16, 0], [3, 0.16, 0]], [-0.460767, [3, -0.16, -0.00981225], [3, 0.16, 0.00981225]], [-0.450955, [3, -0.16, 0], [3, 0.24, 0]], [-0.493905, [3, -0.24, 0.00110459], [3, 0.333333, -0.00153415]], [-0.49544, [3, -0.333333, 0], [3, 0.413333, 0]], [-0.397265, [3, -0.413333, 0], [3, 0, 0]]])
        names.append("LKneePitch")
        times.append([0.96, 1.68, 2.68, 3.16, 3.8, 4.28, 4.76, 5.24, 5.72, 6.2, 6.92, 7.92, 9.16])
        keys.append([[0.363515, [3, -0.333333, 0], [3, 0.24, 0]], [-0.0629359, [3, -0.24, 0], [3, 0.333333, 0]], [-0.0568, [3, -0.333333, 0], [3, 0.16, 0]], [-0.092082, [3, -0.16, 0], [3, 0.213333, 0]], [-0.052114, [3, -0.213333, 0], [3, 0.16, 0]], [-0.052114, [3, -0.16, 0], [3, 0.16, 0]], [-0.052114, [3, -0.16, 0], [3, 0.16, 0]], [-0.052114, [3, -0.16, 0], [3, 0.16, 0]], [-0.052114, [3, -0.16, 0], [3, 0.16, 0]], [-0.061318, [3, -0.16, 0], [3, 0.24, 0]], [0.288349, [3, -0.24, -0.0243599], [3, 0.333333, 0.0338332]], [0.322183, [3, -0.333333, 0], [3, 0.413333, 0]], [0.0705221, [3, -0.413333, 0], [3, 0, 0]]])
        names.append("LShoulderPitch")
        times.append([0.96, 1.68, 2.08, 2.68, 3.8, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[1.25477, [3, -0.333333, 0], [3, 0.24, 0]], [1.2379, [3, -0.24, 0], [3, 0.133333, 0]], [1.25477, [3, -0.133333, 0], [3, 0.2, 0]], [1.2517, [3, -0.2, 0.00306823], [3, 0.373333, -0.00572736]], [-0.207694, [3, -0.373333, 0], [3, 0.64, 0]], [-0.207694, [3, -0.64, 0], [3, 0.16, 0]], [0.420357, [3, -0.16, 0], [3, 0.24, 0]], [-1.21335, [3, -0.24, 0], [3, 0.133333, 0]], [0.420357, [3, -0.133333, 0], [3, 0.2, 0]], [-0.18097, [3, -0.2, 0.152319], [3, 0.173333, -0.13201]], [-0.43263, [3, -0.173333, 0.109371], [3, 0.24, -0.151437]], [-0.963394, [3, -0.24, 0], [3, 0, 0]]])
        names.append("LShoulderRoll")
        times.append([0.96, 1.68, 2.08, 2.68, 3.16, 3.8, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[0.5568, [3, -0.333333, 0], [3, 0.24, 0]], [0.599753, [3, -0.24, 0], [3, 0.133333, 0]], [0.5568, [3, -0.133333, 0], [3, 0.2, 0]], [0.559868, [3, -0.2, 0], [3, 0.16, 0]], [0.45204, [3, -0.16, 0.107828], [3, 0.213333, -0.143771]], [-0.309826, [3, -0.213333, 0], [3, 0.64, 0]], [1.31772, [3, -0.64, 0], [3, 0.16, 0]], [0.363599, [3, -0.16, 0.0756763], [3, 0.24, -0.113514]], [0.250085, [3, -0.24, 0], [3, 0.133333, 0]], [0.363599, [3, -0.133333, -0.113514], [3, 0.2, 0.170272]], [1.25025, [3, -0.2, 0], [3, 0.173333, 0]], [0.654977, [3, -0.173333, 0], [3, 0.24, 0]], [1.06609, [3, -0.24, 0], [3, 0, 0]]])
        names.append("LWristYaw")
        times.append([0.96, 1.68, 2.08, 2.68, 3.8, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[-0.20253, [3, -0.333333, 0], [3, 0.24, 0]], [-0.217869, [3, -0.24, 0], [3, 0.133333, 0]], [-0.20253, [3, -0.133333, 0], [3, 0.2, 0]], [-0.207132, [3, -0.2, 0], [3, 0.373333, 0]], [-0.059784, [3, -0.373333, 0], [3, 0.64, 0]], [-0.282215, [3, -0.64, 0], [3, 0.16, 0]], [0.277696, [3, -0.16, 0], [3, 0.24, 0]], [-0.154892, [3, -0.24, 0], [3, 0.133333, 0]], [0.277696, [3, -0.133333, -0.0734275], [3, 0.2, 0.110141]], [0.395814, [3, -0.2, 0], [3, 0.173333, 0]], [-0.280764, [3, -0.173333, 0], [3, 0.24, 0]], [-0.266959, [3, -0.24, 0], [3, 0, 0]]])
        names.append("RAnklePitch")
        times.append([0.96, 1.68, 2.68, 3.16, 3.8, 4.04, 4.28, 4.52, 4.76, 5, 5.24, 5.48, 5.72, 6.2, 6.92, 7.92, 9.16])
        keys.append([[0.04913, [3, -0.333333, 0], [3, 0.24, 0]], [-0.122678, [3, -0.24, 0.032321], [3, 0.333333, -0.0448903]], [-0.182504, [3, -0.333333, 0], [3, 0.16, 0]], [0.0445279, [3, -0.16, -0.0637212], [3, 0.213333, 0.0849616]], [0.263545, [3, -0.213333, 0], [3, 0.08, 0]], [0.0645772, [3, -0.08, 0], [3, 0.08, 0]], [0.297554, [3, -0.08, 0], [3, 0.08, 0]], [0.0645772, [3, -0.08, 0], [3, 0.08, 0]], [0.297554, [3, -0.08, 0], [3, 0.08, 0]], [0.0645772, [3, -0.08, 0], [3, 0.08, 0]], [0.297554, [3, -0.08, 0], [3, 0.08, 0]], [0.0645772, [3, -0.08, 0], [3, 0.08, 0]], [0.297554, [3, -0.08, 0], [3, 0.16, 0]], [-0.0353239, [3, -0.16, 0], [3, 0.24, 0]], [0.01078, [3, -0.24, -0.0248294], [3, 0.333333, 0.0344853]], [0.14262, [3, -0.333333, 0], [3, 0.413333, 0]], [-0.015298, [3, -0.413333, 0], [3, 0, 0]]])
        names.append("RAnkleRoll")
        times.append([0.96, 1.68, 2.68, 3.16, 3.8, 4.28, 4.76, 5.24, 5.72, 6.2, 6.92, 7.92, 9.16])
        keys.append([[-0.159494, [3, -0.333333, 0], [3, 0.24, 0]], [0.230143, [3, -0.24, 0], [3, 0.333333, 0]], [-0.00456004, [3, -0.333333, 0], [3, 0.16, 0]], [0.289967, [3, -0.16, 0], [3, 0.213333, 0]], [0.256136, [3, -0.213333, 0], [3, 0.16, 0]], [0.256136, [3, -0.16, 0], [3, 0.16, 0]], [0.256136, [3, -0.16, 0], [3, 0.16, 0]], [0.256136, [3, -0.16, 0], [3, 0.16, 0]], [0.256136, [3, -0.16, 0], [3, 0.16, 0]], [0.205514, [3, -0.16, 0.0498949], [3, 0.24, -0.0748424]], [-0.118076, [3, -0.24, 0], [3, 0.333333, 0]], [0.0720561, [3, -0.333333, 0], [3, 0.413333, 0]], [0.047596, [3, -0.413333, 0], [3, 0, 0]]])
        names.append("RElbowRoll")
        times.append([0.96, 1.68, 2.08, 2.68, 3.8, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[1.54462, [3, -0.333333, 0], [3, 0.24, 0]], [0.248551, [3, -0.24, 0], [3, 0.133333, 0]], [1.54462, [3, -0.133333, 0], [3, 0.2, 0]], [0.0349066, [3, -0.2, 0], [3, 0.373333, 0]], [1.54462, [3, -0.373333, 0], [3, 0.64, 0]], [1.54462, [3, -0.64, 0], [3, 0.16, 0]], [1.50481, [3, -0.16, 0], [3, 0.24, 0]], [1.54462, [3, -0.24, 0], [3, 0.133333, 0]], [1.50481, [3, -0.133333, 0], [3, 0.2, 0]], [1.50635, [3, -0.2, 0], [3, 0.173333, 0]], [1.49416, [3, -0.173333, 0], [3, 0.24, 0]], [1.53251, [3, -0.24, 0], [3, 0, 0]]])
        names.append("RElbowYaw")
        times.append([0.96, 1.68, 2.08, 2.68, 3.8, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[1.51095, [3, -0.333333, 0], [3, 0.24, 0]], [-0.158044, [3, -0.24, 0], [3, 0.133333, 0]], [1.51095, [3, -0.133333, 0], [3, 0.2, 0]], [0.084328, [3, -0.2, 0.0878861], [3, 0.373333, -0.164054]], [-0.0797261, [3, -0.373333, 0], [3, 0.64, 0]], [-0.0536481, [3, -0.64, 0], [3, 0.16, 0]], [-0.0628521, [3, -0.16, 0], [3, 0.24, 0]], [-0.061318, [3, -0.24, 0], [3, 0.133333, 0]], [-0.0628521, [3, -0.133333, 0.000613612], [3, 0.2, -0.000920418]], [-0.06592, [3, -0.2, 0.00138461], [3, 0.173333, -0.00119999]], [-0.0706059, [3, -0.173333, 0], [3, 0.24, 0]], [0.352778, [3, -0.24, 0], [3, 0, 0]]])
        names.append("RHand")
        times.append([0.96, 1.68, 2.08, 2.68, 3.8, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[0.0512, [3, -0.333333, 0], [3, 0.24, 0]], [0.046, [3, -0.24, 0], [3, 0.133333, 0]], [0.0512, [3, -0.133333, -0.000266669], [3, 0.2, 0.000400003]], [0.0516, [3, -0.2, -0.000400003], [3, 0.373333, 0.000746672]], [0.8268, [3, -0.373333, -0.000466675], [3, 0.64, 0.000800014]], [0.8276, [3, -0.64, 0], [3, 0.16, 0]], [0.8264, [3, -0.16, 0], [3, 0.24, 0]], [0.8276, [3, -0.24, 0], [3, 0.133333, 0]], [0.8264, [3, -0.133333, 0], [3, 0.2, 0]], [0.828, [3, -0.2, -0.000500008], [3, 0.173333, 0.000433341]], [0.8292, [3, -0.173333, 0], [3, 0.24, 0]], [0.8292, [3, -0.24, 0], [3, 0, 0]]])
        names.append("RHipPitch")
        times.append([0.96, 1.68, 2.68, 3.16, 3.8, 4.04, 4.28, 4.52, 4.76, 5, 5.24, 5.48, 5.72, 6.2, 6.92, 7.92, 9.16])
        keys.append([[0.223922, [3, -0.333333, 0], [3, 0.24, 0]], [0.130348, [3, -0.24, 0], [3, 0.333333, 0]], [0.174835, [3, -0.333333, -0.0297127], [3, 0.16, 0.0142621]], [0.262272, [3, -0.16, 0], [3, 0.213333, 0]], [-0.716335, [3, -0.213333, 0], [3, 0.08, 0]], [-0.321141, [3, -0.08, 0], [3, 0.08, 0]], [-0.716335, [3, -0.08, 0], [3, 0.08, 0]], [-0.321141, [3, -0.08, 0], [3, 0.08, 0]], [-0.716335, [3, -0.08, 0], [3, 0.08, 0]], [-0.321141, [3, -0.08, 0], [3, 0.08, 0]], [-0.716335, [3, -0.08, 0], [3, 0.08, 0]], [-0.321141, [3, -0.08, 0], [3, 0.08, 0]], [-0.716335, [3, -0.08, 0], [3, 0.16, 0]], [-0.151824, [3, -0.16, -0.147253], [3, 0.24, 0.220879]], [0.38806, [3, -0.24, 0], [3, 0.333333, 0]], [0.248551, [3, -0.333333, 0.0406327], [3, 0.413333, -0.0503846]], [0.115008, [3, -0.413333, 0], [3, 0, 0]]])
        names.append("RHipRoll")
        times.append([0.96, 1.68, 2.68, 3.16, 3.8, 4.28, 4.76, 5.24, 5.72, 6.2, 6.92, 7.92, 9.16])
        keys.append([[0.233209, [3, -0.333333, 0], [3, 0.24, 0]], [-0.332836, [3, -0.24, 0], [3, 0.333333, 0]], [-0.0551821, [3, -0.333333, 0], [3, 0.16, 0]], [-0.381923, [3, -0.16, 0], [3, 0.213333, 0]], [-0.151908, [3, -0.213333, 0], [3, 0.16, 0]], [-0.151908, [3, -0.16, 0], [3, 0.16, 0]], [-0.151908, [3, -0.16, 0], [3, 0.16, 0]], [-0.151908, [3, -0.16, 0], [3, 0.16, 0]], [-0.151908, [3, -0.16, 0], [3, 0.16, 0]], [-0.274628, [3, -0.16, 0], [3, 0.24, 0]], [0.161112, [3, -0.24, 0], [3, 0.333333, 0]], [-0.105888, [3, -0.333333, 0], [3, 0.413333, 0]], [-0.049046, [3, -0.413333, 0], [3, 0, 0]]])
        names.append("RKneePitch")
        times.append([0.96, 1.68, 2.68, 3.16, 3.8, 4.04, 4.28, 4.52, 4.76, 5, 5.24, 5.48, 5.72, 6.2, 6.92, 7.92, 9.16])
        keys.append([[-0.061318, [3, -0.333333, 0], [3, 0.24, 0]], [0.285367, [3, -0.24, -0.0265075], [3, 0.333333, 0.036816]], [0.322183, [3, -0.333333, 0], [3, 0.16, 0]], [-0.041376, [3, -0.16, 0], [3, 0.213333, 0]], [1.29312, [3, -0.213333, 0], [3, 0.08, 0]], [0.788889, [3, -0.08, 0], [3, 0.08, 0]], [1.29312, [3, -0.08, 0], [3, 0.08, 0]], [0.788889, [3, -0.08, 0], [3, 0.08, 0]], [1.29312, [3, -0.08, 0], [3, 0.08, 0]], [0.788889, [3, -0.08, 0], [3, 0.08, 0]], [1.29312, [3, -0.08, 0], [3, 0.08, 0]], [0.788889, [3, -0.08, 0], [3, 0.08, 0]], [1.29312, [3, -0.08, 0], [3, 0.16, 0]], [0.363515, [3, -0.16, 0.18141], [3, 0.24, -0.272115]], [-0.067454, [3, -0.24, 0], [3, 0.333333, 0]], [-0.0568, [3, -0.333333, -0.010654], [3, 0.413333, 0.013211]], [0.099752, [3, -0.413333, 0], [3, 0, 0]]])
        names.append("RShoulderPitch")
        times.append([0.96, 1.68, 2.08, 2.68, 3.8, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[0.420357, [3, -0.333333, 0], [3, 0.24, 0]], [-1.21335, [3, -0.24, 0], [3, 0.133333, 0]], [0.420357, [3, -0.133333, 0], [3, 0.2, 0]], [-0.18097, [3, -0.2, 0], [3, 0.373333, 0]], [1.15813, [3, -0.373333, 0], [3, 0.64, 0]], [1.12745, [3, -0.64, 0], [3, 0.16, 0]], [1.25477, [3, -0.16, 0], [3, 0.24, 0]], [1.2379, [3, -0.24, 0], [3, 0.133333, 0]], [1.25477, [3, -0.133333, 0], [3, 0.2, 0]], [1.2517, [3, -0.2, 0], [3, 0.173333, 0]], [1.25639, [3, -0.173333, -0.00468623], [3, 0.24, 0.00648863]], [1.62915, [3, -0.24, 0], [3, 0, 0]]])
        names.append("RShoulderRoll")
        times.append([0.96, 1.68, 2.08, 2.68, 3.8, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[-0.363599, [3, -0.333333, 0], [3, 0.24, 0]], [-0.250085, [3, -0.24, 0], [3, 0.133333, 0]], [-0.363599, [3, -0.133333, 0.113514], [3, 0.2, -0.170272]], [-1.25025, [3, -0.2, 0], [3, 0.373333, 0]], [-0.566003, [3, -0.373333, 0], [3, 0.64, 0]], [-0.570606, [3, -0.64, 0], [3, 0.16, 0]], [-0.5568, [3, -0.16, 0], [3, 0.24, 0]], [-0.599753, [3, -0.24, 0], [3, 0.133333, 0]], [-0.5568, [3, -0.133333, 0], [3, 0.2, 0]], [-0.559868, [3, -0.2, 0], [3, 0.173333, 0]], [-0.552281, [3, -0.173333, 0], [3, 0.24, 0]], [-0.584497, [3, -0.24, 0], [3, 0, 0]]])
        names.append("RWristYaw")
        times.append([0.96, 1.68, 2.08, 2.68, 3.8, 5.72, 6.2, 6.92, 7.32, 7.92, 8.44, 9.16])
        keys.append([[-0.277696, [3, -0.333333, 0], [3, 0.24, 0]], [0.154892, [3, -0.24, 0], [3, 0.133333, 0]], [-0.277696, [3, -0.133333, 0.0734275], [3, 0.2, -0.110141]], [-0.395814, [3, -0.2, 0], [3, 0.373333, 0]], [-0.31903, [3, -0.373333, -0.0243122], [3, 0.64, 0.0416781]], [-0.197844, [3, -0.64, -0.121187], [3, 0.16, 0.0302967]], [0.20253, [3, -0.16, -0.0102265], [3, 0.24, 0.0153397]], [0.217869, [3, -0.24, 0], [3, 0.133333, 0]], [0.20253, [3, -0.133333, 0], [3, 0.2, 0]], [0.207132, [3, -0.2, -0.00245032], [3, 0.173333, 0.00212361]], [0.216252, [3, -0.173333, 0], [3, 0.24, 0]], [0.01223, [3, -0.24, 0], [3, 0, 0]]])
        try:
          # uncomment the following line and modify the IP if you use this script outside Choregraphe.
          # motion = ALProxy("ALMotion", IP, 9559)
          motion = ALProxy("ALMotion")
          motion.angleInterpolationBezier(names, times, keys)
        except BaseException, err:
          print err
################################################################################################################################################################################################################################################################################################################################################################################################
    def snap(self):
        names = list()
        times = list()
        keys = list()
        names.append("HeadPitch")
        times.append([0.44, 1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[-0.339056, [3, -0.16, 0], [3, 0.266667, 0]], [0.381923, [3, -0.266667, -0.0102276], [3, 0.24, 0.00920485]], [0.391128, [3, -0.24, 0], [3, 0.306667, 0]], [0.391128, [3, -0.306667, 0], [3, 0.306667, 0]], [0.391128, [3, -0.306667, 0], [3, 0.306667, 0]], [0.391128, [3, -0.306667, 0], [3, 0.306667, 0]], [0.391128, [3, -0.306667, 0], [3, 0.306667, 0]], [0.391128, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("HeadYaw")
        times.append([0.44, 1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[-0.0614019, [3, -0.16, 0], [3, 0.266667, 0]], [-0.046062, [3, -0.266667, -0.0017046], [3, 0.24, 0.00153414]], [-0.0445279, [3, -0.24, 0], [3, 0.306667, 0]], [-0.0445279, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0445279, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0445279, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0445279, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0445279, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("LAnklePitch")
        times.append([1.24, 1.64, 1.96, 2.56, 2.88, 3.48, 3.8, 4.4, 4.72, 5.32, 5.64, 6.24, 6.56])
        keys.append([[0.18864, [3, -0.426667, 0], [3, 0.133333, 0]], [0.329867, [3, -0.133333, -0.0920878], [3, 0.106667, 0.0736702]], [0.685914, [3, -0.106667, 0], [3, 0.2, 0]], [0.171042, [3, -0.2, 0.137729], [3, 0.106667, -0.0734556]], [0.0523599, [3, -0.106667, 0.0291394], [3, 0.2, -0.0546364]], [-0.0802851, [3, -0.2, 0], [3, 0.106667, 0]], [-0.0802851, [3, -0.106667, 0], [3, 0.2, 0]], [-0.0418879, [3, -0.2, -0.0288359], [3, 0.106667, 0.0153791]], [0.0523599, [3, -0.106667, -0.0552435], [3, 0.2, 0.103581]], [0.434587, [3, -0.2, -0.100546], [3, 0.106667, 0.0536246]], [0.514872, [3, -0.106667, 0], [3, 0.2, 0]], [0.197222, [3, -0.2, 0.0929296], [3, 0.106667, -0.0495625]], [0.087396, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LAnkleRoll")
        times.append([1.24, 1.64, 1.96, 2.56, 2.88, 3.8, 4.72, 5.32, 5.64, 6.24, 6.56])
        keys.append([[-0.317496, [3, -0.426667, 0], [3, 0.133333, 0]], [-0.322886, [3, -0.133333, 0], [3, 0.106667, 0]], [-0.193243, [3, -0.106667, 0], [3, 0.2, 0]], [-0.200713, [3, -0.2, 0], [3, 0.106667, 0]], [-0.0735901, [3, -0.106667, -0.0350834], [3, 0.306667, 0.100865]], [0.207132, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0994838, [3, -0.306667, 0.0988345], [3, 0.2, -0.0644573]], [-0.282743, [3, -0.2, 0], [3, 0.106667, 0]], [-0.193243, [3, -0.106667, -0.00625526], [3, 0.2, 0.0117286]], [-0.181514, [3, -0.2, -0.0117286], [3, 0.106667, 0.00625526]], [-0.0735901, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LElbowRoll")
        times.append([0.44, 0.84, 1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[-0.604353, [3, -0.16, 0], [3, 0.133333, 0]], [-0.657989, [3, -0.133333, 0.0536357], [3, 0.133333, -0.0536357]], [-1.50021, [3, -0.133333, 0], [3, 0.24, 0]], [-1.48027, [3, -0.24, 0], [3, 0.306667, 0]], [-1.48027, [3, -0.306667, 0], [3, 0.306667, 0]], [-1.48027, [3, -0.306667, 0], [3, 0.306667, 0]], [-1.48027, [3, -0.306667, 0], [3, 0.306667, 0]], [-1.48027, [3, -0.306667, 0], [3, 0.306667, 0]], [-1.48027, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("LElbowYaw")
        times.append([0.44, 1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[-1.36377, [3, -0.16, 0], [3, 0.266667, 0]], [-0.521602, [3, -0.266667, -0.0068184], [3, 0.24, 0.00613656]], [-0.515466, [3, -0.24, 0], [3, 0.306667, 0]], [-0.515466, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.515466, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.515466, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.515466, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.515466, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("LHand")
        times.append([0.44, 0.84, 1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[0.7004, [3, -0.16, 0], [3, 0.133333, 0]], [0.9, [3, -0.133333, 0], [3, 0.133333, 0]], [0.6, [3, -0.133333, 0], [3, 0.24, 0]], [0.6016, [3, -0.24, 0], [3, 0.306667, 0]], [0.6016, [3, -0.306667, 0], [3, 0.306667, 0]], [0.6016, [3, -0.306667, 0], [3, 0.306667, 0]], [0.6016, [3, -0.306667, 0], [3, 0.306667, 0]], [0.6016, [3, -0.306667, 0], [3, 0.306667, 0]], [0.6016, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("LHipPitch")
        times.append([1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[0.082878, [3, -0.426667, 0], [3, 0.24, 0]], [-0.194775, [3, -0.24, 0], [3, 0.306667, 0]], [0.392746, [3, -0.306667, -0.0912336], [3, 0.306667, 0.0912336]], [0.48398, [3, -0.306667, 0], [3, 0.306667, 0]], [0.401949, [3, -0.306667, 0.0820305], [3, 0.306667, -0.0820305]], [-0.194775, [3, -0.306667, 0], [3, 0.306667, 0]], [0.392746, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("LHipRoll")
        times.append([1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[0.397349, [3, -0.426667, 0], [3, 0.24, 0]], [0.50166, [3, -0.24, 0], [3, 0.306667, 0]], [0.139636, [3, -0.306667, 0.110448], [3, 0.306667, -0.110448]], [-0.161028, [3, -0.306667, 0], [3, 0.306667, 0]], [0.14117, [3, -0.306667, -0.110448], [3, 0.306667, 0.110448]], [0.50166, [3, -0.306667, 0], [3, 0.306667, 0]], [0.139636, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("LHipYawPitch")
        times.append([1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[-0.398797, [3, -0.426667, 0], [3, 0.24, 0]], [-0.512313, [3, -0.24, 0], [3, 0.306667, 0]], [-0.449421, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.509245, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.450955, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.512313, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.449421, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("LKneePitch")
        times.append([1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[-0.092082, [3, -0.426667, 0], [3, 0.24, 0]], [-0.066004, [3, -0.24, 0], [3, 0.306667, 0]], [-0.0782759, [3, -0.306667, 0.003068], [3, 0.306667, -0.003068]], [-0.084412, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.075208, [3, -0.306667, -0.003068], [3, 0.306667, 0.003068]], [-0.066004, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0782759, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("LShoulderPitch")
        times.append([0.44, 1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[-1.01862, [3, -0.16, 0], [3, 0.266667, 0]], [-0.0568, [3, -0.266667, -0.0170445], [3, 0.24, 0.01534]], [-0.0414599, [3, -0.24, 0], [3, 0.306667, 0]], [-0.0414599, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0414599, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0414599, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0414599, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0414599, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("LShoulderRoll")
        times.append([0.44, 1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[0.11961, [3, -0.16, 0], [3, 0.266667, 0]], [-0.012314, [3, -0.266667, 0], [3, 0.24, 0]], [0.01223, [3, -0.24, 0], [3, 0.306667, 0]], [0.01223, [3, -0.306667, 0], [3, 0.306667, 0]], [0.01223, [3, -0.306667, 0], [3, 0.306667, 0]], [0.01223, [3, -0.306667, 0], [3, 0.306667, 0]], [0.01223, [3, -0.306667, 0], [3, 0.306667, 0]], [0.01223, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("LWristYaw")
        times.append([0.44, 0.84, 1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[1.10597, [3, -0.16, 0], [3, 0.133333, 0]], [-1.07512, [3, -0.133333, 0.241091], [3, 0.133333, -0.241091]], [-1.31621, [3, -0.133333, 0], [3, 0.24, 0]], [-1.29014, [3, -0.24, 0], [3, 0.306667, 0]], [-1.29014, [3, -0.306667, 0], [3, 0.306667, 0]], [-1.29014, [3, -0.306667, 0], [3, 0.306667, 0]], [-1.29014, [3, -0.306667, 0], [3, 0.306667, 0]], [-1.29014, [3, -0.306667, 0], [3, 0.306667, 0]], [-1.29014, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("RAnklePitch")
        times.append([1.24, 1.96, 2.56, 2.88, 3.48, 3.8, 4.4, 4.72, 5.32, 5.64, 6.56])
        keys.append([[0.105888, [3, -0.426667, 0], [3, 0.24, 0]], [0.0575959, [3, -0.24, 0.0183003], [3, 0.2, -0.0152503]], [0.00523599, [3, -0.2, 0.0144179], [3, 0.106667, -0.00768957]], [-0.00872665, [3, -0.106667, 0], [3, 0.2, 0]], [0.230383, [3, -0.2, -0.112308], [3, 0.106667, 0.0598977]], [0.507891, [3, -0.106667, 0], [3, 0.2, 0]], [0.0453786, [3, -0.2, 0.0523599], [3, 0.106667, -0.0279253]], [0.0174533, [3, -0.106667, 0], [3, 0.2, 0]], [0.0174533, [3, -0.2, 0], [3, 0.106667, 0]], [0.0174533, [3, -0.106667, 0], [3, 0.306667, 0]], [0.090548, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("RAnkleRoll")
        times.append([1.24, 1.96, 2.56, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[-0.148756, [3, -0.426667, 0], [3, 0.24, 0]], [-0.305225, [3, -0.24, 0], [3, 0.2, 0]], [0.00872665, [3, -0.2, -0.0910397], [3, 0.106667, 0.0485545]], [0.113558, [3, -0.106667, -0.023533], [3, 0.306667, 0.0676575]], [0.282298, [3, -0.306667, 0], [3, 0.306667, 0]], [0.1309, [3, -0.306667, 0.0979205], [3, 0.306667, -0.0979205]], [-0.305225, [3, -0.306667, 0], [3, 0.306667, 0]], [0.113558, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("RElbowRoll")
        times.append([1.24, 1.52, 1.76, 1.96, 2.16, 2.44, 2.68, 2.88, 3.08, 3.36, 3.6, 3.8, 4, 4.28, 4.52, 4.72, 4.92, 5.2, 5.44, 5.64, 5.84, 6.12, 6.36, 6.56])
        keys.append([[1.53558, [3, -0.426667, 0], [3, 0.0933333, 0]], [1.02625, [3, -0.0933333, 0], [3, 0.08, 0]], [1.4591, [3, -0.08, 0], [3, 0.0666667, 0]], [0.329852, [3, -0.0666667, 0], [3, 0.0666667, 0]], [1.53558, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.02625, [3, -0.0933333, 0], [3, 0.08, 0]], [1.4591, [3, -0.08, 0], [3, 0.0666667, 0]], [0.329852, [3, -0.0666667, 0], [3, 0.0666667, 0]], [1.53558, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.02625, [3, -0.0933333, 0], [3, 0.08, 0]], [1.4591, [3, -0.08, 0], [3, 0.0666667, 0]], [0.329852, [3, -0.0666667, 0], [3, 0.0666667, 0]], [1.53558, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.02625, [3, -0.0933333, 0], [3, 0.08, 0]], [1.4591, [3, -0.08, 0], [3, 0.0666667, 0]], [0.329852, [3, -0.0666667, 0], [3, 0.0666667, 0]], [1.53558, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.02625, [3, -0.0933333, 0], [3, 0.08, 0]], [1.4591, [3, -0.08, 0], [3, 0.0666667, 0]], [0.329852, [3, -0.0666667, 0], [3, 0.0666667, 0]], [1.53558, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.02625, [3, -0.0933333, 0], [3, 0.08, 0]], [1.4591, [3, -0.08, 0], [3, 0.0666667, 0]], [0.329852, [3, -0.0666667, 0], [3, 0, 0]]])
        names.append("RElbowYaw")
        times.append([0.6, 1.24, 1.52, 1.96, 2.16, 2.44, 2.88, 3.08, 3.36, 3.8, 4, 4.28, 4.72, 4.92, 5.2, 5.64, 5.84, 6.12, 6.56])
        keys.append([[1.80816, [3, -0.213333, 0], [3, 0.213333, 0]], [0.94797, [3, -0.213333, 0], [3, 0.0933333, 0]], [1.42244, [3, -0.0933333, 0], [3, 0.146667, 0]], [1.20261, [3, -0.146667, 0.108733], [3, 0.0666667, -0.0494243]], [0.94797, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.42244, [3, -0.0933333, 0], [3, 0.146667, 0]], [1.20261, [3, -0.146667, 0.108733], [3, 0.0666667, -0.0494243]], [0.94797, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.42244, [3, -0.0933333, 0], [3, 0.146667, 0]], [1.20261, [3, -0.146667, 0.108733], [3, 0.0666667, -0.0494243]], [0.94797, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.42244, [3, -0.0933333, 0], [3, 0.146667, 0]], [1.20261, [3, -0.146667, 0.108733], [3, 0.0666667, -0.0494243]], [0.94797, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.42244, [3, -0.0933333, 0], [3, 0.146667, 0]], [1.20261, [3, -0.146667, 0.108733], [3, 0.0666667, -0.0494243]], [0.94797, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.42244, [3, -0.0933333, 0], [3, 0.146667, 0]], [1.20261, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("RHand")
        times.append([0.6, 1.24, 1.52, 1.76, 1.96, 2.16, 2.44, 2.68, 2.88, 3.08, 3.36, 3.6, 3.8, 4, 4.28, 4.52, 4.72, 4.92, 5.2, 5.44, 5.64, 5.84, 6.12, 6.36, 6.56])
        keys.append([[0.7, [3, -0.213333, 0], [3, 0.213333, 0]], [0, [3, -0.213333, 0], [3, 0.0933333, 0]], [1, [3, -0.0933333, 0], [3, 0.08, 0]], [0, [3, -0.08, 0], [3, 0.0666667, 0]], [0.8, [3, -0.0666667, 0], [3, 0.0666667, 0]], [0, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1, [3, -0.0933333, 0], [3, 0.08, 0]], [0, [3, -0.08, 0], [3, 0.0666667, 0]], [0.8, [3, -0.0666667, 0], [3, 0.0666667, 0]], [0, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1, [3, -0.0933333, 0], [3, 0.08, 0]], [0, [3, -0.08, 0], [3, 0.0666667, 0]], [0.8, [3, -0.0666667, 0], [3, 0.0666667, 0]], [0, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1, [3, -0.0933333, 0], [3, 0.08, 0]], [0, [3, -0.08, 0], [3, 0.0666667, 0]], [0.8, [3, -0.0666667, 0], [3, 0.0666667, 0]], [0, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1, [3, -0.0933333, 0], [3, 0.08, 0]], [0, [3, -0.08, 0], [3, 0.0666667, 0]], [0.8, [3, -0.0666667, 0], [3, 0.0666667, 0]], [0, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1, [3, -0.0933333, 0], [3, 0.08, 0]], [0, [3, -0.08, 0], [3, 0.0666667, 0]], [0.8, [3, -0.0666667, 0], [3, 0, 0]]])
        names.append("RHipPitch")
        times.append([1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[0.236194, [3, -0.426667, 0], [3, 0.24, 0]], [0.325165, [3, -0.24, -0.0278366], [3, 0.306667, 0.0355689]], [0.42641, [3, -0.306667, 0], [3, 0.306667, 0]], [0.056716, [3, -0.306667, 0], [3, 0.306667, 0]], [0.423342, [3, -0.306667, 0], [3, 0.306667, 0]], [0.325165, [3, -0.306667, 0], [3, 0.306667, 0]], [0.42641, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("RHipRoll")
        times.append([1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[0.234743, [3, -0.426667, 0], [3, 0.24, 0]], [0.345191, [3, -0.24, 0], [3, 0.306667, 0]], [-0.191709, [3, -0.306667, 0.119908], [3, 0.306667, -0.119908]], [-0.374254, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.194775, [3, -0.306667, -0.119908], [3, 0.306667, 0.119908]], [0.345191, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.191709, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("RKneePitch")
        times.append([1.24, 1.96, 2.88, 3.8, 4.72, 5.64, 6.56])
        keys.append([[-0.0923279, [3, -0.426667, 0], [3, 0.24, 0]], [-0.0923279, [3, -0.24, 0], [3, 0.306667, 0]], [-0.0923279, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0923279, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0923279, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0923279, [3, -0.306667, 0], [3, 0.306667, 0]], [-0.0923279, [3, -0.306667, 0], [3, 0, 0]]])
        names.append("RShoulderPitch")
        times.append([1.24, 1.52, 1.76, 1.96, 2.16, 2.44, 2.68, 2.88, 3.08, 3.36, 3.6, 3.8, 4, 4.28, 4.52, 4.72, 4.92, 5.2, 5.44, 5.64, 5.84, 6.12, 6.36, 6.56])
        keys.append([[1.28247, [3, -0.426667, 0], [3, 0.0933333, 0]], [1.51146, [3, -0.0933333, -0.0504985], [3, 0.08, 0.0432844]], [1.56381, [3, -0.08, 0], [3, 0.0666667, 0]], [1.38371, [3, -0.0666667, 0.0468915], [3, 0.0666667, -0.0468915]], [1.28247, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.51146, [3, -0.0933333, -0.0504985], [3, 0.08, 0.0432844]], [1.56381, [3, -0.08, 0], [3, 0.0666667, 0]], [1.38371, [3, -0.0666667, 0.0468915], [3, 0.0666667, -0.0468915]], [1.28247, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.51146, [3, -0.0933333, -0.0504985], [3, 0.08, 0.0432844]], [1.56381, [3, -0.08, 0], [3, 0.0666667, 0]], [1.38371, [3, -0.0666667, 0.0468915], [3, 0.0666667, -0.0468915]], [1.28247, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.51146, [3, -0.0933333, -0.0504985], [3, 0.08, 0.0432844]], [1.56381, [3, -0.08, 0], [3, 0.0666667, 0]], [1.38371, [3, -0.0666667, 0.0468915], [3, 0.0666667, -0.0468915]], [1.28247, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.51146, [3, -0.0933333, -0.0504985], [3, 0.08, 0.0432844]], [1.56381, [3, -0.08, 0], [3, 0.0666667, 0]], [1.38371, [3, -0.0666667, 0.0468915], [3, 0.0666667, -0.0468915]], [1.28247, [3, -0.0666667, 0], [3, 0.0933333, 0]], [1.51146, [3, -0.0933333, -0.0504985], [3, 0.08, 0.0432844]], [1.56381, [3, -0.08, 0], [3, 0.0666667, 0]], [1.38371, [3, -0.0666667, 0], [3, 0, 0]]])
        names.append("RShoulderRoll")
        times.append([0.6, 1.24, 1.96, 2.16, 2.88, 3.08, 3.8, 4, 4.72, 4.92, 5.64, 5.84, 6.56])
        keys.append([[0.23911, [3, -0.213333, 0], [3, 0.213333, 0]], [-0.286901, [3, -0.213333, 0], [3, 0.24, 0]], [-0.168782, [3, -0.24, 0], [3, 0.0666667, 0]], [-0.286901, [3, -0.0666667, 0], [3, 0.24, 0]], [-0.168782, [3, -0.24, 0], [3, 0.0666667, 0]], [-0.286901, [3, -0.0666667, 0], [3, 0.24, 0]], [-0.168782, [3, -0.24, 0], [3, 0.0666667, 0]], [-0.286901, [3, -0.0666667, 0], [3, 0.24, 0]], [-0.168782, [3, -0.24, 0], [3, 0.0666667, 0]], [-0.286901, [3, -0.0666667, 0], [3, 0.24, 0]], [-0.168782, [3, -0.24, 0], [3, 0.0666667, 0]], [-0.286901, [3, -0.0666667, 0], [3, 0.24, 0]], [-0.168782, [3, -0.24, 0], [3, 0, 0]]])
        names.append("RWristYaw")
        times.append([0.6, 1.24, 1.76, 1.96, 2.16, 2.68, 2.88, 3.08, 3.6, 3.8, 4, 4.52, 4.72, 4.92, 5.44, 5.64, 5.84, 6.36, 6.56])
        keys.append([[0.98262, [3, -0.213333, 0], [3, 0.213333, 0]], [1.3238, [3, -0.213333, 0], [3, 0.173333, 0]], [1.16937, [3, -0.173333, 0], [3, 0.0666667, 0]], [1.33692, [3, -0.0666667, 0], [3, 0.0666667, 0]], [1.3238, [3, -0.0666667, 0.0131214], [3, 0.173333, -0.0341156]], [1.16937, [3, -0.173333, 0], [3, 0.0666667, 0]], [1.33692, [3, -0.0666667, 0], [3, 0.0666667, 0]], [1.3238, [3, -0.0666667, 0.0131214], [3, 0.173333, -0.0341156]], [1.16937, [3, -0.173333, 0], [3, 0.0666667, 0]], [1.33692, [3, -0.0666667, 0], [3, 0.0666667, 0]], [1.3238, [3, -0.0666667, 0.0131214], [3, 0.173333, -0.0341156]], [1.16937, [3, -0.173333, 0], [3, 0.0666667, 0]], [1.33692, [3, -0.0666667, 0], [3, 0.0666667, 0]], [1.3238, [3, -0.0666667, 0.0131214], [3, 0.173333, -0.0341156]], [1.16937, [3, -0.173333, 0], [3, 0.0666667, 0]], [1.33692, [3, -0.0666667, 0], [3, 0.0666667, 0]], [1.3238, [3, -0.0666667, 0.0131214], [3, 0.173333, -0.0341156]], [1.16937, [3, -0.173333, 0], [3, 0.0666667, 0]], [1.33692, [3, -0.0666667, 0], [3, 0, 0]]])
        try:
          # uncomment the following line and modify the IP if you use this script outside Choregraphe.
          # motion = ALProxy("ALMotion", IP, 9559)
          motion = ALProxy("ALMotion")
          motion.angleInterpolationBezier(names, times, keys)
        except BaseException, err:
          print err
################################################################################################################################################################################################################################################################################################################################################################################################
    def wave(self):
    # Choregraphe bezier export in Python.
        names = list()
        times = list()
        keys = list()
        names.append("HeadPitch")
        times.append([0.56, 0.92, 3.4, 3.96, 4.32, 6.8])
        keys.append([[0.460158, [3, -0.2, 0], [3, 0.12, 0]], [-0.058334, [3, -0.12, 0.0111339], [3, 0.826667, -0.0767001]], [-0.135034, [3, -0.826667, 0], [3, 0.186667, 0]], [0.44175, [3, -0.186667, 0], [3, 0.12, 0]], [-0.058334, [3, -0.12, 0.0111339], [3, 0.826667, -0.0767001]], [-0.135034, [3, -0.826667, 0], [3, 0, 0]]])
        names.append("HeadYaw")
        times.append([0.56, 0.92, 3.4, 3.96, 4.32, 6.8])
        keys.append([[0.0827941, [3, -0.2, 0], [3, 0.12, 0]], [-0.880559, [3, -0.12, 0.017146], [3, 0.826667, -0.118117]], [-0.998676, [3, -0.826667, 0], [3, 0.186667, 0]], [-0.0705221, [3, -0.186667, -0.381294], [3, 0.12, 0.245118]], [0.880559, [3, -0.12, -0.017146], [3, 0.826667, 0.118117]], [0.998676, [3, -0.826667, 0], [3, 0, 0]]])
        names.append("LAnklePitch")
        times.append([0.56, 0.84, 1.12, 1.28, 1.48, 1.64, 1.84, 2, 2.2, 2.36, 2.56, 2.72, 2.92, 3.08, 3.4, 3.96, 4.24, 4.52, 4.68, 4.88, 5.04, 5.24, 5.4, 5.6, 5.76, 5.96, 6.12, 6.32, 6.48, 6.8])
        keys.append([[0.024502, [3, -0.2, 0], [3, 0.0933333, 0]], [-0.038392, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.024502, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.024502, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.038392, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.038392, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.024502, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.024502, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.038392, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.038392, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.024502, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.024502, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.038392, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.038392, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.022968, [3, -0.106667, 0], [3, 0.186667, 0]], [-0.0352401, [3, -0.186667, 0.00630379], [3, 0.0933333, -0.00315189]], [-0.038392, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.024502, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.024502, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.038392, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.038392, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.024502, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.024502, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.038392, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.038392, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.024502, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.024502, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.038392, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.038392, [3, -0.0533333, 0], [3, 0.106667, 0]], [-0.0383081, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LAnkleRoll")
        times.append([0.56, 0.84, 1.12, 1.28, 1.48, 1.64, 1.84, 2, 2.2, 2.36, 2.56, 2.72, 2.92, 3.08, 3.4, 3.96, 4.24, 4.52, 4.68, 4.88, 5.04, 5.24, 5.4, 5.6, 5.76, 5.96, 6.12, 6.32, 6.48, 6.8])
        keys.append([[-0.11194, [3, -0.2, 0], [3, 0.0933333, 0]], [-0.138018, [3, -0.0933333, 0], [3, 0.0933333, 0]], [-0.11194, [3, -0.0933333, 0], [3, 0.0533333, 0]], [-0.11194, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.138018, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.138018, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.11194, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.11194, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.138018, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.138018, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.11194, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.11194, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.138018, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.138018, [3, -0.0533333, 0], [3, 0.106667, 0]], [-0.11194, [3, -0.106667, -0.0050102], [3, 0.186667, 0.00876784]], [-0.0966839, [3, -0.186667, 0], [3, 0.0933333, 0]], [-0.138018, [3, -0.0933333, 0], [3, 0.0933333, 0]], [-0.11194, [3, -0.0933333, 0], [3, 0.0533333, 0]], [-0.11194, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.138018, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.138018, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.11194, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.11194, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.138018, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.138018, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.11194, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.11194, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.138018, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.138018, [3, -0.0533333, 0], [3, 0.106667, 0]], [-0.0966839, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LElbowRoll")
        times.append([0.24, 0.56, 0.84, 0.92, 1.2, 1.28, 1.56, 1.64, 1.92, 2, 2.28, 2.36, 2.64, 2.72, 3, 3.08, 3.4, 3.96, 4.24, 4.32, 4.6, 4.68, 4.96, 5.04, 5.32, 5.4, 5.68, 5.76, 6.04, 6.12, 6.4, 6.48, 6.8])
        keys.append([[-1.2706, [3, -0.0933333, 0], [3, 0.106667, 0]], [-1.49561, [3, -0.106667, 0], [3, 0.0933333, 0]], [-1.45726, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.45726, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.45572, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.45572, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.45572, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.45572, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.45572, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.45572, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.45572, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.45572, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.45572, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.45572, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.45572, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.45572, [3, -0.0266667, 0], [3, 0.106667, 0]], [-1.54462, [3, -0.106667, 0], [3, 0.186667, 0]], [-1.17662, [3, -0.186667, -0.0582939], [3, 0.0933333, 0.029147]], [-1.14747, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.14747, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.31772, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.31772, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.29852, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.29852, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.22724, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.22724, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.11833, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.11833, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.940383, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.940383, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.638187, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.638187, [3, -0.0266667, 0], [3, 0.106667, 0]], [-0.0349066, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LElbowYaw")
        times.append([0.24, 0.56, 0.84, 0.92, 1.2, 1.28, 1.56, 1.64, 1.92, 2, 2.28, 2.36, 2.64, 2.72, 3, 3.08, 3.4, 3.68, 3.96, 4.24, 4.32, 4.6, 4.68, 4.96, 5.04, 5.32, 5.4, 5.68, 5.76, 6.04, 6.12, 6.4, 6.48, 6.8])
        keys.append([[-0.93026, [3, -0.0933333, 0], [3, 0.106667, 0]], [-0.036858, [3, -0.106667, -0.0280504], [3, 0.0933333, 0.0245441]], [-0.012314, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.012314, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.00302603, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.00302603, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.00924597, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.00924597, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.00924597, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.00924597, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.00924597, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.00924597, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.00771196, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.00771196, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.013764, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.013764, [3, -0.0266667, 0], [3, 0.106667, 0]], [0.078192, [3, -0.106667, -0.0644279], [3, 0.0933333, 0.0563744]], [0.567232, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.0750492, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.119694, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.119694, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.010472, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.010472, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.019984, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.019984, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.032256, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.032256, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.046062, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.046062, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.0598679, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.0598679, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.0782759, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.0782759, [3, -0.0266667, 0], [3, 0.106667, 0]], [0.0966839, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LHand")
        times.append([0.56, 0.84, 0.92, 3.4, 3.96, 4.24, 4.32, 6.8])
        keys.append([[0.5932, [3, -0.2, 0], [3, 0.0933333, 0]], [0.5924, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.5924, [3, -0.0266667, 0], [3, 0.826667, 0]], [0.5948, [3, -0.826667, 0], [3, 0.186667, 0]], [0.3084, [3, -0.186667, 0], [3, 0.0933333, 0]], [0.6988, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.6988, [3, -0.0266667, 0], [3, 0.826667, 0]], [0.7936, [3, -0.826667, 0], [3, 0, 0]]])
        names.append("LHipPitch")
        times.append([0.56, 0.84, 1.12, 1.28, 1.48, 1.64, 1.84, 2, 2.2, 2.36, 2.56, 2.72, 2.92, 3.08, 3.4, 3.96, 4.24, 4.52, 4.68, 4.88, 5.04, 5.24, 5.4, 5.6, 5.76, 5.96, 6.12, 6.32, 6.48, 6.8])
        keys.append([[0.161112, [3, -0.2, 0], [3, 0.0933333, 0]], [0.274628, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.161112, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.161112, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.274628, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.274628, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.161112, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.161112, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.274628, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.274628, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.161112, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.161112, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.274628, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.274628, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.159578, [3, -0.106667, 0], [3, 0.186667, 0]], [0.167164, [3, -0.186667, -0.00758608], [3, 0.0933333, 0.00379304]], [0.274628, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.161112, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.161112, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.274628, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.274628, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.161112, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.161112, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.274628, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.274628, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.161112, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.161112, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.274628, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.274628, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.167164, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LHipRoll")
        times.append([0.56, 0.84, 1.12, 1.28, 1.48, 1.64, 1.84, 2, 2.2, 2.36, 2.56, 2.72, 2.92, 3.08, 3.4, 3.96, 4.24, 4.52, 4.68, 4.88, 5.04, 5.24, 5.4, 5.6, 5.76, 5.96, 6.12, 6.32, 6.48, 6.8])
        keys.append([[0.168782, [3, -0.2, 0], [3, 0.0933333, 0]], [0.224006, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.168782, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.168782, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.224006, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.224006, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168782, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168782, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.224006, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.224006, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168782, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168782, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.224006, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.224006, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.168782, [3, -0.106667, 0.00874933], [3, 0.186667, -0.0153113]], [0.151824, [3, -0.186667, 0], [3, 0.0933333, 0]], [0.224006, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.168782, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.168782, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.224006, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.224006, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168782, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168782, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.224006, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.224006, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168782, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168782, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.224006, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.224006, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.153358, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LHipYawPitch")
        times.append([0.56, 0.84, 1.12, 1.28, 1.48, 1.64, 1.84, 2, 2.2, 2.36, 2.56, 2.72, 2.92, 3.08, 3.4, 3.96, 4.24, 4.52, 4.68, 4.88, 5.04, 5.24, 5.4, 5.6, 5.76, 5.96, 6.12, 6.32, 6.48, 6.8])
        keys.append([[-0.492371, [3, -0.2, 0], [3, 0.0933333, 0]], [-0.461692, [3, -0.0933333, 0], [3, 0.0933333, 0]], [-0.492371, [3, -0.0933333, 0], [3, 0.0533333, 0]], [-0.492371, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.461692, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.461692, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.492371, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.492371, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.461692, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.461692, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.492371, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.492371, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.461692, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.461692, [3, -0.0533333, 0], [3, 0.106667, 0]], [-0.493905, [3, -0.106667, 0], [3, 0.186667, 0]], [-0.492371, [3, -0.186667, -0.00153415], [3, 0.0933333, 0.000767074]], [-0.461692, [3, -0.0933333, 0], [3, 0.0933333, 0]], [-0.492371, [3, -0.0933333, 0], [3, 0.0533333, 0]], [-0.492371, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.461692, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.461692, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.492371, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.492371, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.461692, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.461692, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.492371, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.492371, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.461692, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.461692, [3, -0.0533333, 0], [3, 0.106667, 0]], [-0.493905, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LKneePitch")
        times.append([0.56, 0.84, 1.12, 1.28, 1.48, 1.64, 1.84, 2, 2.2, 2.36, 2.56, 2.72, 2.92, 3.08, 3.4, 3.96, 4.24, 4.52, 4.68, 4.88, 5.04, 5.24, 5.4, 5.6, 5.76, 5.96, 6.12, 6.32, 6.48, 6.8])
        keys.append([[0.168698, [3, -0.2, 0], [3, 0.0933333, 0]], [0.193243, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.168698, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.193243, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.193243, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168698, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.193243, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.193243, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168698, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.193243, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.193243, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.170232, [3, -0.106667, 0], [3, 0.186667, 0]], [0.222472, [3, -0.186667, 0], [3, 0.0933333, 0]], [0.193243, [3, -0.0933333, 0.0089623], [3, 0.0933333, -0.0089623]], [0.168698, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.193243, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.193243, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168698, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.193243, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.193243, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168698, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.193243, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.193243, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.222472, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LShoulderPitch")
        times.append([0.24, 0.56, 0.84, 0.92, 1.2, 1.28, 1.56, 1.64, 1.92, 2, 2.28, 2.36, 2.64, 2.72, 3, 3.08, 3.4, 3.96, 4.24, 4.32, 4.6, 4.68, 4.96, 5.04, 5.32, 5.4, 5.68, 5.76, 6.04, 6.12, 6.4, 6.48, 6.8])
        keys.append([[1.32994, [3, -0.0933333, 0], [3, 0.106667, 0]], [1.13052, [3, -0.106667, 0.0192845], [3, 0.0933333, -0.0168739]], [1.11364, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.11364, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.10751, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.10751, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.11518, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.11518, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.11518, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.11518, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.11518, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.11518, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.11211, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.11211, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.0937, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.0937, [3, -0.0266667, 0], [3, 0.106667, 0]], [1.01547, [3, -0.106667, 0.0782344], [3, 0.186667, -0.13691]], [-0.417134, [3, -0.186667, 0], [3, 0.0933333, 0]], [-0.314428, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.314428, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.228525, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.228525, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.20398, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.20398, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.171766, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.171766, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.14262, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.14262, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.105804, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.105804, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.061318, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.061318, [3, -0.0266667, 0], [3, 0.106667, 0]], [-0.00149204, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LShoulderRoll")
        times.append([0.24, 0.56, 0.84, 0.92, 1.2, 1.28, 1.56, 1.64, 1.92, 2, 2.28, 2.36, 2.64, 2.72, 3, 3.08, 3.4, 3.96, 4.24, 4.32, 4.6, 4.68, 4.96, 5.04, 5.32, 5.4, 5.68, 5.76, 6.04, 6.12, 6.4, 6.48, 6.8])
        keys.append([[0.610865, [3, -0.0933333, 0], [3, 0.106667, 0]], [0.259204, [3, -0.106667, 0.00876654], [3, 0.0933333, -0.00767072]], [0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.251533, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.251533, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.251533, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.251533, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.251533, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.251533, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.251533, [3, -0.0266667, 0], [3, 0.106667, 0]], [0.289883, [3, -0.106667, 0], [3, 0.186667, 0]], [-0.292952, [3, -0.186667, 0], [3, 0.0933333, 0]], [0.01078, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.01078, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.225147, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.225147, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.467748, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.467748, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.68766, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.68766, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.888373, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.888373, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.01578, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.01578, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.07384, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.07384, [3, -0.0266667, 0], [3, 0.106667, 0]], [1.26406, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LWristYaw")
        times.append([0.56, 0.84, 0.92, 3.4, 3.96, 4.24, 4.32, 4.6, 4.68, 6.8])
        keys.append([[-0.492455, [3, -0.2, 0], [3, 0.0933333, 0]], [-0.461776, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.461776, [3, -0.0266667, 0], [3, 0.826667, 0]], [-0.546147, [3, -0.826667, 0], [3, 0.186667, 0]], [-0.530721, [3, -0.186667, -0.0154252], [3, 0.0933333, 0.00771261]], [-0.262272, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.262272, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.122173, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.122173, [3, -0.0266667, 0], [3, 0.706667, 0]], [-0.156426, [3, -0.706667, 0], [3, 0, 0]]])
        names.append("RAnklePitch")
        times.append([0.56, 0.84, 1.12, 1.28, 1.48, 1.64, 1.84, 2, 2.2, 2.36, 2.56, 2.72, 2.92, 3.08, 3.4, 3.96, 4.24, 4.52, 4.68, 4.88, 5.04, 5.24, 5.4, 5.6, 5.76, 5.96, 6.12, 6.32, 6.48, 6.8])
        keys.append([[-0.0383081, [3, -0.2, 0], [3, 0.0933333, 0]], [-0.128814, [3, -0.0933333, 0], [3, 0.0933333, 0]], [-0.0383081, [3, -0.0933333, 0], [3, 0.0533333, 0]], [-0.0383081, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.128814, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.128814, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.0383081, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.0383081, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.128814, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.128814, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.0383081, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.0383081, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.128814, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.128814, [3, -0.0533333, 0], [3, 0.106667, 0]], [-0.0383081, [3, -0.106667, -0.0187697], [3, 0.186667, 0.032847]], [0.0260361, [3, -0.186667, 0], [3, 0.0933333, 0]], [-0.128814, [3, -0.0933333, 0], [3, 0.0933333, 0]], [-0.0383081, [3, -0.0933333, 0], [3, 0.0533333, 0]], [-0.0383081, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.128814, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.128814, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.0383081, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.0383081, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.128814, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.128814, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.0383081, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.0383081, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.128814, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.128814, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.022968, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RAnkleRoll")
        times.append([0.56, 0.84, 1.12, 1.28, 1.48, 1.64, 1.84, 2, 2.2, 2.36, 2.56, 2.72, 2.92, 3.08, 3.4, 3.96, 4.24, 4.52, 4.68, 4.88, 5.04, 5.24, 5.4, 5.6, 5.76, 5.96, 6.12, 6.32, 6.48, 6.8])
        keys.append([[0.0966839, [3, -0.2, 0], [3, 0.0933333, 0]], [0.112024, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.0966839, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.0966839, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.112024, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.112024, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.0966839, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.0966839, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.112024, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.112024, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.0966839, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.0966839, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.112024, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.112024, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.0966839, [3, -0.106667, 0], [3, 0.186667, 0]], [0.11194, [3, -0.186667, -0.000167896], [3, 0.0933333, 8.39478e-05]], [0.112024, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.0966839, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.0966839, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.112024, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.112024, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.0966839, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.0966839, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.112024, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.112024, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.0966839, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.0966839, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.112024, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.112024, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.11194, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RElbowRoll")
        times.append([0.56, 0.84, 0.92, 1.2, 1.28, 1.56, 1.64, 1.92, 2, 2.28, 2.36, 2.64, 2.72, 3, 3.08, 3.4, 3.68, 3.96, 4.24, 4.32, 4.6, 4.68, 4.96, 5.04, 5.32, 5.4, 5.68, 5.76, 6.04, 6.12, 6.4, 6.48, 6.8])
        keys.append([[1.19043, [3, -0.2, 0], [3, 0.0933333, 0]], [1.14747, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.14747, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.31772, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.31772, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.29852, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.29852, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.22724, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.22724, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.11833, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.11833, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.940383, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.940383, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.638187, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.638187, [3, -0.0266667, 0], [3, 0.106667, 0]], [0.0349066, [3, -0.106667, 0], [3, 0.0933333, 0]], [1.35612, [3, -0.0933333, -0.131818], [3, 0.0933333, 0.131818]], [1.48794, [3, -0.0933333, 0], [3, 0.0933333, 0]], [1.45726, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.45726, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.45572, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.45572, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.45572, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.45572, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.45572, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.45572, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.45572, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.45572, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.45572, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.45572, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.45572, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.45572, [3, -0.0266667, 0], [3, 0.106667, 0]], [1.54462, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RElbowYaw")
        times.append([0.56, 0.84, 0.92, 1.2, 1.28, 1.56, 1.64, 1.92, 2, 2.28, 2.36, 2.64, 2.72, 3, 3.08, 3.4, 3.96, 4.24, 4.32, 4.6, 4.68, 4.96, 5.04, 5.32, 5.4, 5.68, 5.76, 6.04, 6.12, 6.4, 6.48, 6.8])
        keys.append([[-0.342125, [3, -0.2, 0], [3, 0.0933333, 0]], [-0.119694, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.119694, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.010472, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.010472, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.019984, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.019984, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.032256, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.032256, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.046062, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.046062, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.0598679, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.0598679, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.0782759, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.0782759, [3, -0.0266667, 0], [3, 0.106667, 0]], [-0.0966839, [3, -0.106667, 0], [3, 0.186667, 0]], [0.0245859, [3, -0.186667, 0], [3, 0.0933333, 0]], [0.012314, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.012314, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.00302603, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.00302603, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.00924597, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.00924597, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.00924597, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.00924597, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.00924597, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.00924597, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.00771196, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.00771196, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.013764, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.013764, [3, -0.0266667, 0], [3, 0.106667, 0]], [-0.078192, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RHand")
        times.append([0.56, 0.84, 0.92, 3.4, 3.96, 4.24, 4.32, 6.8])
        keys.append([[0.306, [3, -0.2, 0], [3, 0.0933333, 0]], [0.6988, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.6988, [3, -0.0266667, 0], [3, 0.826667, 0]], [0.7936, [3, -0.826667, 0], [3, 0.186667, 0]], [0.594, [3, -0.186667, 0.00319994], [3, 0.0933333, -0.00159997]], [0.5924, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.5924, [3, -0.0266667, 0], [3, 0.826667, 0]], [0.5948, [3, -0.826667, 0], [3, 0, 0]]])
        names.append("RHipPitch")
        times.append([0.56, 0.84, 1.12, 1.28, 1.48, 1.64, 1.84, 2, 2.2, 2.36, 2.56, 2.72, 2.92, 3.08, 3.4, 3.96, 4.24, 4.52, 4.68, 4.88, 5.04, 5.24, 5.4, 5.6, 5.76, 5.96, 6.12, 6.32, 6.48, 6.8])
        keys.append([[0.168698, [3, -0.2, 0], [3, 0.0933333, 0]], [0.292952, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.168698, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.292952, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.292952, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168698, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.292952, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.292952, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168698, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.292952, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.292952, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.167164, [3, -0.106667, 0.00345825], [3, 0.186667, -0.00605193]], [0.161112, [3, -0.186667, 0], [3, 0.0933333, 0]], [0.292952, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.168698, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.292952, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.292952, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168698, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.292952, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.292952, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168698, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.292952, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.292952, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.159578, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RHipRoll")
        times.append([0.56, 0.84, 1.12, 1.28, 1.48, 1.64, 1.84, 2, 2.2, 2.36, 2.56, 2.72, 2.92, 3.08, 3.4, 3.96, 4.24, 4.52, 4.68, 4.88, 5.04, 5.24, 5.4, 5.6, 5.76, 5.96, 6.12, 6.32, 6.48, 6.8])
        keys.append([[-0.153358, [3, -0.2, 0], [3, 0.0933333, 0]], [-0.199378, [3, -0.0933333, 0], [3, 0.0933333, 0]], [-0.153358, [3, -0.0933333, 0], [3, 0.0533333, 0]], [-0.153358, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.199378, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.199378, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.153358, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.153358, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.199378, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.199378, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.153358, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.153358, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.199378, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.199378, [3, -0.0533333, 0], [3, 0.106667, 0]], [-0.153358, [3, -0.106667, 0], [3, 0.186667, 0]], [-0.168782, [3, -0.186667, 0.0102266], [3, 0.0933333, -0.00511329]], [-0.199378, [3, -0.0933333, 0], [3, 0.0933333, 0]], [-0.153358, [3, -0.0933333, 0], [3, 0.0533333, 0]], [-0.153358, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.199378, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.199378, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.153358, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.153358, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.199378, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.199378, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.153358, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.153358, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.199378, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.199378, [3, -0.0533333, 0], [3, 0.106667, 0]], [-0.168782, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RKneePitch")
        times.append([0.56, 0.84, 1.12, 1.28, 1.48, 1.64, 1.84, 2, 2.2, 2.36, 2.56, 2.72, 2.92, 3.08, 3.4, 3.96, 4.24, 4.52, 4.68, 4.88, 5.04, 5.24, 5.4, 5.6, 5.76, 5.96, 6.12, 6.32, 6.48, 6.8])
        keys.append([[0.222472, [3, -0.2, 0], [3, 0.0933333, 0]], [0.259288, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.222472, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.222472, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.259288, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.259288, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.222472, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.222472, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.259288, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.259288, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.222472, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.222472, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.259288, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.259288, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.222472, [3, -0.106667, 0.0109806], [3, 0.186667, -0.019216]], [0.168698, [3, -0.186667, 0], [3, 0.0933333, 0]], [0.259288, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.222472, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.222472, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.259288, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.259288, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.222472, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.222472, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.259288, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.259288, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.222472, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.222472, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.259288, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.259288, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.170232, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RShoulderPitch")
        times.append([0.56, 0.84, 0.92, 1.2, 1.28, 1.56, 1.64, 1.92, 2, 2.28, 2.36, 2.64, 2.72, 3, 3.08, 3.4, 3.96, 4.24, 4.32, 4.6, 4.68, 4.96, 5.04, 5.32, 5.4, 5.68, 5.76, 6.04, 6.12, 6.4, 6.48, 6.8])
        keys.append([[-0.37272, [3, -0.2, 0], [3, 0.0933333, 0]], [-0.314428, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.314428, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.228525, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.228525, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.20398, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.20398, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.171766, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.171766, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.14262, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.14262, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.105804, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.105804, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.061318, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.061318, [3, -0.0266667, 0], [3, 0.106667, 0]], [-0.00149204, [3, -0.106667, -0.0598259], [3, 0.186667, 0.104695]], [1.12745, [3, -0.186667, 0], [3, 0.0933333, 0]], [1.11364, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.11364, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.10751, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.10751, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.11518, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.11518, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.11518, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.11518, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.11518, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.11518, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.11211, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.11211, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.0937, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.0937, [3, -0.0266667, 0], [3, 0.106667, 0]], [1.01547, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RShoulderRoll")
        times.append([0.56, 0.84, 0.92, 1.2, 1.28, 1.56, 1.64, 1.92, 2, 2.28, 2.36, 2.64, 2.72, 3, 3.08, 3.4, 3.96, 4.24, 4.32, 4.6, 4.68, 4.96, 5.04, 5.32, 5.4, 5.68, 5.76, 6.04, 6.12, 6.4, 6.48, 6.8])
        keys.append([[0.314159, [3, -0.2, 0], [3, 0.0933333, 0]], [-0.01078, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.01078, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.225147, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.225147, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.467748, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.467748, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.68766, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.68766, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.888373, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.888373, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.01578, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.01578, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.07384, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.07384, [3, -0.0266667, 0], [3, 0.106667, 0]], [-1.26406, [3, -0.106667, 0], [3, 0.186667, 0]], [-0.283749, [3, -0.186667, -0.0644306], [3, 0.0933333, 0.0322153]], [-0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.251533, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.251533, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.251533, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.251533, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.251533, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.251533, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.251533, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.251533, [3, -0.0266667, 0], [3, 0.106667, 0]], [-0.289883, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RWristYaw")
        times.append([0.56, 0.84, 0.92, 1.2, 1.28, 3.4, 3.96, 4.24, 4.32, 6.8])
        keys.append([[0.549129, [3, -0.2, 0], [3, 0.0933333, 0]], [0.262272, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.262272, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.122173, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.122173, [3, -0.0266667, 0], [3, 0.706667, 0]], [0.156426, [3, -0.706667, -0.034253], [3, 0.186667, 0.00904795]], [0.515466, [3, -0.186667, 0], [3, 0.0933333, 0]], [0.461776, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.461776, [3, -0.0266667, 0], [3, 0.826667, 0]], [0.546147, [3, -0.826667, 0], [3, 0, 0]]])
        try:
          # uncomment the following line and modify the IP if you use this script outside Choregraphe.
          # motion = ALProxy("ALMotion", IP, 9559)
          motion = ALProxy("ALMotion")
          motion.angleInterpolationBezier(names, times, keys)
        except BaseException, err:
          print err
################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################
    def exp(self):
        # Choregraphe bezier export in Python.
        names = list()
        times = list()
        keys = list()
        names.append("HeadPitch")
        times.append([1.04, 1.4, 3.88])
        keys.append([[0.446352, [3, -0.36, 0], [3, 0.12, 0]], [-0.020944, [3, -0.12, 0.00430702], [3, 0.826667, -0.0296706]], [-0.0506146, [3, -0.826667, 0], [3, 0, 0]]])
        names.append("HeadYaw")
        times.append([1.04, 3.88])
        keys.append([[0.00149204, [3, -0.36, 0], [3, 0.946667, 0]], [0.00609404, [3, -0.946667, 0], [3, 0, 0]]])
        names.append("LAnklePitch")
        times.append([1.04, 1.32, 1.6, 1.76, 1.96, 2.12, 2.32, 2.48, 2.68, 2.84, 3.04, 3.2, 3.4, 3.56, 3.88])
        keys.append([[-0.0353239, [3, -0.36, 0], [3, 0.0933333, 0]], [-0.038392, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.024502, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.024502, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.038392, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.038392, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.024502, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.024502, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.038392, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.038392, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.024502, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.024502, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.038392, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.038392, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.022968, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LAnkleRoll")
        times.append([1.04, 1.32, 1.6, 1.76, 1.96, 2.12, 2.32, 2.48, 2.68, 2.84, 3.04, 3.2, 3.4, 3.56, 3.88])
        keys.append([[-0.0966, [3, -0.36, 0], [3, 0.0933333, 0]], [-0.138018, [3, -0.0933333, 0], [3, 0.0933333, 0]], [-0.11194, [3, -0.0933333, 0], [3, 0.0533333, 0]], [-0.11194, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.138018, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.138018, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.11194, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.11194, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.138018, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.138018, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.11194, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.11194, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.138018, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.138018, [3, -0.0533333, 0], [3, 0.106667, 0]], [-0.11194, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LElbowRoll")
        times.append([0.56, 1.04, 1.32, 1.4, 1.68, 1.76, 2.04, 2.12, 2.4, 2.48, 2.76, 2.84, 3.12, 3.2, 3.48, 3.56, 3.88])
        keys.append([[-0.619592, [3, -0.2, 0], [3, 0.16, 0]], [-1.11824, [3, -0.16, 0.0501068], [3, 0.0933333, -0.029229]], [-1.14747, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.14747, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.31772, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.31772, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.29852, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.29852, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.22724, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.22724, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.11833, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.11833, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.940383, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.940383, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.638187, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.638187, [3, -0.0266667, 0], [3, 0.106667, 0]], [-0.0349066, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LElbowYaw")
        times.append([0.56, 1.04, 1.32, 1.4, 1.68, 1.76, 2.04, 2.12, 2.4, 2.48, 2.76, 2.84, 3.12, 3.2, 3.48, 3.56, 3.88])
        keys.append([[-1.2514, [3, -0.2, 0], [3, 0.16, 0]], [-0.047596, [3, -0.16, -0.286783], [3, 0.0933333, 0.16729]], [0.119694, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.119694, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.010472, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.010472, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.019984, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.019984, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.032256, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.032256, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.046062, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.046062, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.0598679, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.0598679, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.0782759, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.0782759, [3, -0.0266667, 0], [3, 0.106667, 0]], [0.0966839, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LHand")
        times.append([0.56, 1.04, 1.32, 1.4, 3.88])
        keys.append([[0.9, [3, -0.2, 0], [3, 0.16, 0]], [0.3104, [3, -0.16, 0], [3, 0.0933333, 0]], [0.6988, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.6988, [3, -0.0266667, 0], [3, 0.826667, 0]], [0.7936, [3, -0.826667, 0], [3, 0, 0]]])
        names.append("LHipPitch")
        times.append([1.04, 1.32, 1.6, 1.76, 1.96, 2.12, 2.32, 2.48, 2.68, 2.84, 3.04, 3.2, 3.4, 3.56, 3.88])
        keys.append([[0.167248, [3, -0.36, 0], [3, 0.0933333, 0]], [0.274628, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.161112, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.161112, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.274628, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.274628, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.161112, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.161112, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.274628, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.274628, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.161112, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.161112, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.274628, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.274628, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.159578, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LHipRoll")
        times.append([1.04, 1.32, 1.6, 1.76, 1.96, 2.12, 2.32, 2.48, 2.68, 2.84, 3.04, 3.2, 3.4, 3.56, 3.88])
        keys.append([[0.151908, [3, -0.36, 0], [3, 0.0933333, 0]], [0.224006, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.168782, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.168782, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.224006, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.224006, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168782, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168782, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.224006, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.224006, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168782, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168782, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.224006, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.224006, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.168782, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LHipYawPitch")
        times.append([1.04, 1.32, 1.6, 1.76, 1.96, 2.12, 2.32, 2.48, 2.68, 2.84, 3.04, 3.2, 3.4, 3.56, 3.88])
        keys.append([[-0.492371, [3, -0.36, 0], [3, 0.0933333, 0]], [-0.461692, [3, -0.0933333, 0], [3, 0.0933333, 0]], [-0.492371, [3, -0.0933333, 0], [3, 0.0533333, 0]], [-0.492371, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.461692, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.461692, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.492371, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.492371, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.461692, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.461692, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.492371, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.492371, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.461692, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.461692, [3, -0.0533333, 0], [3, 0.106667, 0]], [-0.493905, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LKneePitch")
        times.append([1.04, 1.32, 1.6, 1.76, 1.96, 2.12, 2.32, 2.48, 2.68, 2.84, 3.04, 3.2, 3.4, 3.56, 3.88])
        keys.append([[0.223922, [3, -0.36, 0], [3, 0.0933333, 0]], [0.193243, [3, -0.0933333, 0.00920402], [3, 0.0933333, -0.00920402]], [0.168698, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.193243, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.193243, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168698, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.193243, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.193243, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168698, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.193243, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.193243, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.170232, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LShoulderPitch")
        times.append([0.56, 1.04, 1.32, 1.4, 1.68, 1.76, 2.04, 2.12, 2.4, 2.48, 2.76, 2.84, 3.12, 3.2, 3.48, 3.56, 3.88])
        keys.append([[0.260054, [3, -0.2, 0], [3, 0.16, 0]], [-0.406552, [3, -0.16, 0.15278], [3, 0.0933333, -0.0891218]], [-0.495674, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.495674, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.390954, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.390954, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.20398, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.20398, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.171766, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.171766, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.14262, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.14262, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.105804, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.105804, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.061318, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.061318, [3, -0.0266667, 0], [3, 0.106667, 0]], [-0.00149204, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LShoulderRoll")
        times.append([0.56, 1.04, 1.32, 1.4, 1.68, 1.76, 2.04, 2.12, 2.4, 2.48, 2.76, 2.84, 3.12, 3.2, 3.48, 3.56, 3.88])
        keys.append([[0.989602, [3, -0.2, 0], [3, 0.16, 0]], [-0.271559, [3, -0.16, 0], [3, 0.0933333, 0]], [0.01078, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.01078, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.225147, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.225147, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.467748, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.467748, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.68766, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.68766, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.888373, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.888373, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.01578, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.01578, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.07384, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.07384, [3, -0.0266667, 0], [3, 0.106667, 0]], [1.26406, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LWristYaw")
        times.append([0.56, 1.04, 1.32, 1.4, 1.68, 1.76, 3.88])
        keys.append([[-1.59872, [3, -0.2, 0], [3, 0.16, 0]], [-0.575292, [3, -0.16, -0.281358], [3, 0.0933333, 0.164125]], [-0.262272, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.262272, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.122173, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.122173, [3, -0.0266667, 0], [3, 0.706667, 0]], [-0.156426, [3, -0.706667, 0], [3, 0, 0]]])
        names.append("RAnklePitch")
        times.append([1.04, 1.32, 1.6, 1.76, 1.96, 2.12, 2.32, 2.48, 2.68, 2.84, 3.04, 3.2, 3.4, 3.56, 3.88])
        keys.append([[0.0261199, [3, -0.36, 0], [3, 0.0933333, 0]], [-0.128814, [3, -0.0933333, 0], [3, 0.0933333, 0]], [-0.0383081, [3, -0.0933333, 0], [3, 0.0533333, 0]], [-0.0383081, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.128814, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.128814, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.0383081, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.0383081, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.128814, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.128814, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.0383081, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.0383081, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.128814, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.128814, [3, -0.0533333, 0], [3, 0.106667, 0]], [-0.0383081, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RAnkleRoll")
        times.append([1.04, 1.32, 1.6, 1.76, 1.96, 2.12, 2.32, 2.48, 2.68, 2.84, 3.04, 3.2, 3.4, 3.56, 3.88])
        keys.append([[0.112024, [3, -0.36, 0], [3, 0.0933333, 0]], [0.112024, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.0966839, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.0966839, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.112024, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.112024, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.0966839, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.0966839, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.112024, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.112024, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.0966839, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.0966839, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.112024, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.112024, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.0966839, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RElbowRoll")
        times.append([0.56, 1.04, 1.32, 1.4, 1.68, 1.76, 2.04, 2.12, 2.4, 2.48, 2.76, 2.84, 3.12, 3.2, 3.48, 3.56, 3.88])
        keys.append([[0.572468, [3, -0.2, 0], [3, 0.16, 0]], [1.54462, [3, -0.16, 0], [3, 0.0933333, 0]], [1.14747, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.14747, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.31772, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.31772, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.29852, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.29852, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.22724, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.22724, [3, -0.0266667, 0], [3, 0.0933333, 0]], [1.11833, [3, -0.0933333, 0], [3, 0.0266667, 0]], [1.11833, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.940383, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.940383, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.638187, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.638187, [3, -0.0266667, 0], [3, 0.106667, 0]], [0.0349066, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RElbowYaw")
        times.append([0.56, 1.04, 1.32, 1.4, 1.68, 1.76, 2.04, 2.12, 2.4, 2.48, 2.76, 2.84, 3.12, 3.2, 3.48, 3.56, 3.88])
        keys.append([[1.16588, [3, -0.2, 0], [3, 0.16, 0]], [-4.19617e-05, [3, -0.16, 0.205118], [3, 0.0933333, -0.119652]], [-0.119694, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.119694, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.010472, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.010472, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.019984, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.019984, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.032256, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.032256, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.046062, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.046062, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.0598679, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.0598679, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.0782759, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.0782759, [3, -0.0266667, 0], [3, 0.106667, 0]], [-0.0966839, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RHand")
        times.append([0.56, 1.04, 1.32, 1.4, 3.88])
        keys.append([[0.8, [3, -0.2, 0], [3, 0.16, 0]], [0.5936, [3, -0.16, 0], [3, 0.0933333, 0]], [0.6988, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.6988, [3, -0.0266667, 0], [3, 0.826667, 0]], [0.7936, [3, -0.826667, 0], [3, 0, 0]]])
        names.append("RHipPitch")
        times.append([1.04, 1.32, 1.6, 1.76, 1.96, 2.12, 2.32, 2.48, 2.68, 2.84, 3.04, 3.2, 3.4, 3.56, 3.88])
        keys.append([[0.161028, [3, -0.36, 0], [3, 0.0933333, 0]], [0.292952, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.168698, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.292952, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.292952, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168698, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.292952, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.292952, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.168698, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.168698, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.292952, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.292952, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.167164, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RHipRoll")
        times.append([1.04, 1.32, 1.6, 1.76, 1.96, 2.12, 2.32, 2.48, 2.68, 2.84, 3.04, 3.2, 3.4, 3.56, 3.88])
        keys.append([[-0.167164, [3, -0.36, 0], [3, 0.0933333, 0]], [-0.199378, [3, -0.0933333, 0], [3, 0.0933333, 0]], [-0.153358, [3, -0.0933333, 0], [3, 0.0533333, 0]], [-0.153358, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.199378, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.199378, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.153358, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.153358, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.199378, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.199378, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.153358, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.153358, [3, -0.0533333, 0], [3, 0.0666667, 0]], [-0.199378, [3, -0.0666667, 0], [3, 0.0533333, 0]], [-0.199378, [3, -0.0533333, 0], [3, 0.106667, 0]], [-0.153358, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RKneePitch")
        times.append([1.04, 1.32, 1.6, 1.76, 1.96, 2.12, 2.32, 2.48, 2.68, 2.84, 3.04, 3.2, 3.4, 3.56, 3.88])
        keys.append([[0.168782, [3, -0.36, 0], [3, 0.0933333, 0]], [0.259288, [3, -0.0933333, 0], [3, 0.0933333, 0]], [0.222472, [3, -0.0933333, 0], [3, 0.0533333, 0]], [0.222472, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.259288, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.259288, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.222472, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.222472, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.259288, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.259288, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.222472, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.222472, [3, -0.0533333, 0], [3, 0.0666667, 0]], [0.259288, [3, -0.0666667, 0], [3, 0.0533333, 0]], [0.259288, [3, -0.0533333, 0], [3, 0.106667, 0]], [0.222472, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RShoulderPitch")
        times.append([0.56, 1.04, 1.32, 1.4, 1.68, 1.76, 2.04, 2.12, 2.4, 2.48, 2.76, 2.84, 3.12, 3.2, 3.48, 3.56, 3.88])
        keys.append([[0.286234, [3, -0.2, 0], [3, 0.16, 0]], [0.245482, [3, -0.16, 0.0407517], [3, 0.0933333, -0.0237718]], [0, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.0523599, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.0523599, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.20398, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.20398, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.171766, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.171766, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.14262, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.14262, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.105804, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.105804, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.061318, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.061318, [3, -0.0266667, 0], [3, 0.106667, 0]], [-0.00149204, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RShoulderRoll")
        times.append([0.56, 1.04, 1.32, 1.4, 1.68, 1.76, 2.04, 2.12, 2.4, 2.48, 2.76, 2.84, 3.12, 3.2, 3.48, 3.56, 3.88])
        keys.append([[-0.998328, [3, -0.2, 0], [3, 0.16, 0]], [0.141086, [3, -0.16, 0], [3, 0.0933333, 0]], [-0.01078, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.01078, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.225147, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.225147, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.467748, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.467748, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.68766, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.68766, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-0.888373, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-0.888373, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.01578, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.01578, [3, -0.0266667, 0], [3, 0.0933333, 0]], [-1.07384, [3, -0.0933333, 0], [3, 0.0266667, 0]], [-1.07384, [3, -0.0266667, 0], [3, 0.106667, 0]], [-1.26406, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RWristYaw")
        times.append([0.56, 1.04, 1.32, 1.4, 1.68, 1.76, 3.88])
        keys.append([[1.07512, [3, -0.2, 0], [3, 0.16, 0]], [0.269941, [3, -0.16, 0.0131468], [3, 0.0933333, -0.00766899]], [0.262272, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.262272, [3, -0.0266667, 0], [3, 0.0933333, 0]], [0.122173, [3, -0.0933333, 0], [3, 0.0266667, 0]], [0.122173, [3, -0.0266667, 0], [3, 0.706667, 0]], [0.156426, [3, -0.706667, 0], [3, 0, 0]]])
        try:
          # uncomment the following line and modify the IP if you use this script outside Choregraphe.
          # motion = ALProxy("ALMotion", IP, 9559)
          motion = ALProxy("ALMotion")
          motion.angleInterpolationBezier(names, times, keys)
        except BaseException, err:
          print err
################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################
    def Disco2(self):
        # Choregraphe bezier export in Python.
        names = list()
        times = list()
        keys = list()
        names.append("HeadPitch")
        times.append([0.4, 1.08, 1.76, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[-0.144238, [3, -0.146667, 0], [3, 0.226667, 0]], [-0.107422, [3, -0.226667, 0], [3, 0.226667, 0]], [-0.17185, [3, -0.226667, 0], [3, 0.253333, 0]], [-0.130432, [3, -0.253333, 0], [3, 0.16, 0]], [-0.17185, [3, -0.16, 0], [3, 0.173333, 0]], [-0.130432, [3, -0.173333, -0.00664731], [3, 0.28, 0.010738]], [-0.119694, [3, -0.28, 0], [3, 0.04, 0]], [-0.14884, [3, -0.04, 0], [3, 0.306667, 0]], [-0.119694, [3, -0.306667, 0], [3, 0.04, 0]], [-0.14884, [3, -0.04, 0], [3, 0.146667, 0]], [-0.136536, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("HeadYaw")
        times.append([0.4, 1.08, 1.76, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[-0.113558, [3, -0.146667, 0], [3, 0.226667, 0]], [0.0275701, [3, -0.226667, 0], [3, 0.226667, 0]], [-0.0982179, [3, -0.226667, 0], [3, 0.253333, 0]], [0.0183661, [3, -0.253333, 0], [3, 0.16, 0]], [-0.0982179, [3, -0.16, 0], [3, 0.173333, 0]], [0.0183661, [3, -0.173333, 0], [3, 0.28, 0]], [-0.023052, [3, -0.28, 0], [3, 0.04, 0]], [-0.00617796, [3, -0.04, 0], [3, 0.306667, 0]], [-0.023052, [3, -0.306667, 0], [3, 0.04, 0]], [-0.00617796, [3, -0.04, 0], [3, 0.146667, 0]], [-0.014923, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("LAnklePitch")
        times.append([0, 0.4, 1.08, 1.76, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[-0.046062, [3, -0.0133333, 0], [3, 0.133333, 0]], [0.0444441, [3, -0.133333, -0.0255667], [3, 0.226667, 0.0434634]], [0.161028, [3, -0.226667, 0], [3, 0.226667, 0]], [0.05058, [3, -0.226667, 0], [3, 0.253333, 0]], [0.161028, [3, -0.253333, 0], [3, 0.16, 0]], [0.05058, [3, -0.16, 0], [3, 0.173333, 0]], [0.161028, [3, -0.173333, 0], [3, 0.28, 0]], [0.0367741, [3, -0.28, 0.0107378], [3, 0.04, -0.00153397]], [0.0352401, [3, -0.04, 0], [3, 0.306667, 0]], [0.0367741, [3, -0.306667, 0], [3, 0.04, 0]], [0.0352401, [3, -0.04, 0], [3, 0.146667, 0]], [0.0764751, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("LAnkleRoll")
        times.append([0, 0.4, 1.08, 1.76, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[-0.0183661, [3, -0.0133333, 0], [3, 0.133333, 0]], [0.062936, [3, -0.133333, 0], [3, 0.226667, 0]], [-0.248467, [3, -0.226667, 0], [3, 0.226667, 0]], [0.07214, [3, -0.226667, 0], [3, 0.253333, 0]], [-0.248467, [3, -0.253333, 0], [3, 0.16, 0]], [0.07214, [3, -0.16, 0], [3, 0.173333, 0]], [-0.248467, [3, -0.173333, 0], [3, 0.28, 0]], [-0.11194, [3, -0.28, 0], [3, 0.04, 0]], [-0.11194, [3, -0.04, 0], [3, 0.306667, 0]], [-0.11194, [3, -0.306667, 0], [3, 0.04, 0]], [-0.11194, [3, -0.04, 0], [3, 0.146667, 0]], [-0.0958187, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("LElbowRoll")
        times.append([0, 0.4, 0.48, 1.08, 1.76, 1.84, 2.52, 3, 3.52, 3.92, 4, 4.36, 4.48, 4.92, 5, 5.4, 5.52, 5.96])
        keys.append([[-1.12923, [3, -0.0133333, 0], [3, 0.133333, 0]], [-0.369652, [3, -0.133333, 0], [3, 0.0266667, 0]], [-0.369652, [3, -0.0266667, 0], [3, 0.2, 0]], [-0.202446, [3, -0.2, 0], [3, 0.226667, 0]], [-0.398797, [3, -0.226667, 0], [3, 0.0266667, 0]], [-0.369652, [3, -0.0266667, -0.00581305], [3, 0.226667, 0.0494109]], [-0.233125, [3, -0.226667, 0], [3, 0.16, 0]], [-0.398797, [3, -0.16, 0], [3, 0.173333, 0]], [-0.233125, [3, -0.173333, 0], [3, 0.133333, 0]], [-1.2514, [3, -0.133333, 0], [3, 0.0266667, 0]], [-1.2514, [3, -0.0266667, 0], [3, 0.12, 0]], [-0.052114, [3, -0.12, 0], [3, 0.04, 0]], [-0.075124, [3, -0.04, 0.0230101], [3, 0.146667, -0.0843703]], [-1.02625, [3, -0.146667, 0], [3, 0.0266667, 0]], [-1.02625, [3, -0.0266667, 0], [3, 0.133333, 0]], [-0.052114, [3, -0.133333, 0], [3, 0.04, 0]], [-0.075124, [3, -0.04, 0.0230101], [3, 0.146667, -0.0843703]], [-0.503112, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("LElbowYaw")
        times.append([0, 0.4, 0.48, 1.08, 1.76, 1.84, 2.52, 3, 3.52, 3.92, 4, 4.36, 4.48, 4.92, 5, 5.4, 5.52, 5.96])
        keys.append([[-1.76453, [3, -0.0133333, 0], [3, 0.133333, 0]], [-0.380475, [3, -0.133333, 0], [3, 0.0266667, 0]], [-0.380475, [3, -0.0266667, 0], [3, 0.2, 0]], [-0.618244, [3, -0.2, 0], [3, 0.226667, 0]], [-0.385075, [3, -0.226667, -0.0391058], [3, 0.0266667, 0.00460068]], [-0.380475, [3, -0.0266667, 0], [3, 0.226667, 0]], [-0.612108, [3, -0.226667, 0], [3, 0.16, 0]], [-0.385075, [3, -0.16, 0], [3, 0.173333, 0]], [-1.61443, [3, -0.173333, 0], [3, 0.133333, 0]], [-0.438078, [3, -0.133333, 0], [3, 0.0266667, 0]], [-0.438078, [3, -0.0266667, 0], [3, 0.12, 0]], [-0.205598, [3, -0.12, 0], [3, 0.04, 0]], [-0.214801, [3, -0.04, 0.00920314], [3, 0.146667, -0.0337448]], [-1.23046, [3, -0.146667, 0], [3, 0.0266667, 0]], [-1.23046, [3, -0.0266667, 0], [3, 0.133333, 0]], [-0.205598, [3, -0.133333, 0], [3, 0.04, 0]], [-0.214801, [3, -0.04, 0.00920314], [3, 0.146667, -0.0337448]], [-1.19724, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("LHand")
        times.append([0, 0.4, 0.48, 1.08, 1.76, 1.84, 2.52, 3, 3.52, 3.92, 4, 4.36, 4.48, 4.92, 5, 5.4, 5.52, 5.96])
        keys.append([[0.6, [3, -0.0133333, 0], [3, 0.133333, 0]], [0.2648, [3, -0.133333, 0], [3, 0.0266667, 0]], [0.2648, [3, -0.0266667, 0], [3, 0.2, 0]], [0.264, [3, -0.2, 0], [3, 0.226667, 0]], [0.264, [3, -0.226667, 0], [3, 0.0266667, 0]], [0.2648, [3, -0.0266667, 0], [3, 0.226667, 0]], [0.264, [3, -0.226667, 0], [3, 0.16, 0]], [0.264, [3, -0.16, 0], [3, 0.173333, 0]], [0.264, [3, -0.173333, 0], [3, 0.133333, 0]], [0.8, [3, -0.133333, 0], [3, 0.0266667, 0]], [0.8, [3, -0.0266667, 0], [3, 0.12, 0]], [0.9836, [3, -0.12, 0], [3, 0.04, 0]], [0.982, [3, -0.04, 0.00160003], [3, 0.146667, -0.00586677]], [0.8, [3, -0.146667, 0], [3, 0.0266667, 0]], [0.8, [3, -0.0266667, 0], [3, 0.133333, 0]], [0.9836, [3, -0.133333, 0], [3, 0.04, 0]], [0.982, [3, -0.04, 0.00160003], [3, 0.146667, -0.00586677]], [0.312197, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("LHipPitch")
        times.append([0, 0.4, 1.08, 1.76, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[-0.153358, [3, -0.0133333, 0], [3, 0.133333, 0]], [0.185656, [3, -0.133333, 0], [3, 0.226667, 0]], [0.147306, [3, -0.226667, 0], [3, 0.226667, 0]], [0.331386, [3, -0.226667, 0], [3, 0.253333, 0]], [0.147306, [3, -0.253333, 0], [3, 0.16, 0]], [0.331386, [3, -0.16, 0], [3, 0.173333, 0]], [0.147306, [3, -0.173333, 0], [3, 0.28, 0]], [0.328317, [3, -0.28, 0], [3, 0.04, 0]], [0.328317, [3, -0.04, 0], [3, 0.306667, 0]], [0.328317, [3, -0.306667, 0], [3, 0.04, 0]], [0.328317, [3, -0.04, 0], [3, 0.146667, 0]], [0.15824, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("LHipRoll")
        times.append([0, 0.4, 1.08, 1.76, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[0.00464395, [3, -0.0133333, 0], [3, 0.133333, 0]], [-0.144154, [3, -0.133333, 0], [3, 0.226667, 0]], [0.329852, [3, -0.226667, 0], [3, 0.226667, 0]], [-0.11961, [3, -0.226667, 0], [3, 0.253333, 0]], [0.329852, [3, -0.253333, 0], [3, 0.16, 0]], [-0.11961, [3, -0.16, 0], [3, 0.173333, 0]], [0.329852, [3, -0.173333, 0], [3, 0.28, 0]], [0.142704, [3, -0.28, 0], [3, 0.04, 0]], [0.142704, [3, -0.04, 0], [3, 0.306667, 0]], [0.142704, [3, -0.306667, 0], [3, 0.04, 0]], [0.142704, [3, -0.04, 0], [3, 0.146667, 0]], [0.0969995, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("LHipYawPitch")
        times.append([0, 0.4, 1.08, 1.76, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[-0.443284, [3, -0.0133333, 0], [3, 0.133333, 0]], [-0.37272, [3, -0.133333, -0.00902336], [3, 0.226667, 0.0153397]], [-0.357381, [3, -0.226667, -0.00357938], [3, 0.226667, 0.00357938]], [-0.351244, [3, -0.226667, 0], [3, 0.253333, 0]], [-0.357381, [3, -0.253333, 0], [3, 0.16, 0]], [-0.351244, [3, -0.16, 0], [3, 0.173333, 0]], [-0.357381, [3, -0.173333, 0], [3, 0.28, 0]], [-0.328234, [3, -0.28, 0], [3, 0.04, 0]], [-0.328234, [3, -0.04, 0], [3, 0.306667, 0]], [-0.328234, [3, -0.306667, 0], [3, 0.04, 0]], [-0.328234, [3, -0.04, 0], [3, 0.146667, 0]], [-0.161593, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("LKneePitch")
        times.append([0, 0.4, 1.08, 1.76, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[0.404934, [3, -0.0133333, 0], [3, 0.133333, 0]], [-0.090548, [3, -0.133333, 0], [3, 0.226667, 0]], [-0.0798099, [3, -0.226667, 0], [3, 0.226667, 0]], [-0.090548, [3, -0.226667, 0], [3, 0.253333, 0]], [-0.0798099, [3, -0.253333, 0], [3, 0.16, 0]], [-0.090548, [3, -0.16, 0], [3, 0.173333, 0]], [-0.0798099, [3, -0.173333, 0], [3, 0.28, 0]], [-0.090548, [3, -0.28, 0], [3, 0.04, 0]], [-0.090548, [3, -0.04, 0], [3, 0.306667, 0]], [-0.090548, [3, -0.306667, 0], [3, 0.04, 0]], [-0.090548, [3, -0.04, 0], [3, 0.146667, 0]], [-0.0856063, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("LShoulderPitch")
        times.append([0.4, 0.48, 1.08, 1.76, 1.84, 2.52, 3, 3.52, 3.92, 4, 4.36, 4.48, 4.92, 5, 5.4, 5.52, 5.96])
        keys.append([[1.74718, [3, -0.146667, 0], [3, 0.0266667, 0]], [1.74718, [3, -0.0266667, 0], [3, 0.2, 0]], [1.85611, [3, -0.2, 0], [3, 0.226667, 0]], [1.73184, [3, -0.226667, 0], [3, 0.0266667, 0]], [1.74718, [3, -0.0266667, -0.00322953], [3, 0.226667, 0.027451]], [1.82389, [3, -0.226667, 0], [3, 0.16, 0]], [1.73184, [3, -0.16, 0], [3, 0.173333, 0]], [1.82389, [3, -0.173333, 0], [3, 0.133333, 0]], [0.286234, [3, -0.133333, 0], [3, 0.0266667, 0]], [0.286234, [3, -0.0266667, 0], [3, 0.12, 0]], [-0.0261199, [3, -0.12, 0], [3, 0.04, 0]], [0.049046, [3, -0.04, 0], [3, 0.146667, 0]], [-0.364774, [3, -0.146667, 0], [3, 0.0266667, 0]], [-0.364774, [3, -0.0266667, 0], [3, 0.133333, 0]], [-0.0261199, [3, -0.133333, -0.106108], [3, 0.04, 0.0318323]], [0.049046, [3, -0.04, -0.0751659], [3, 0.146667, 0.275608]], [1.47202, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("LShoulderRoll")
        times.append([0.4, 0.48, 1.08, 1.76, 1.84, 2.52, 3, 3.52, 3.92, 4, 4.36, 4.48, 4.92, 5, 5.4, 5.52, 5.96])
        keys.append([[0.24233, [3, -0.146667, 0], [3, 0.0266667, 0]], [0.24233, [3, -0.0266667, 0], [3, 0.2, 0]], [0.196309, [3, -0.2, 0], [3, 0.226667, 0]], [0.210117, [3, -0.226667, -0.0137255], [3, 0.0266667, 0.00161477]], [0.24233, [3, -0.0266667, 0], [3, 0.226667, 0]], [0.207048, [3, -0.226667, 0], [3, 0.16, 0]], [0.210117, [3, -0.16, 0], [3, 0.173333, 0]], [0.207048, [3, -0.173333, 0], [3, 0.133333, 0]], [0.568977, [3, -0.133333, 0], [3, 0.0266667, 0]], [0.568977, [3, -0.0266667, 0], [3, 0.12, 0]], [-0.04913, [3, -0.12, 0], [3, 0.04, 0]], [-0.023052, [3, -0.04, -0.026078], [3, 0.146667, 0.0956194]], [0.342085, [3, -0.146667, 0], [3, 0.0266667, 0]], [0.342085, [3, -0.0266667, 0], [3, 0.133333, 0]], [-0.04913, [3, -0.133333, 0], [3, 0.04, 0]], [-0.023052, [3, -0.04, -0.0185179], [3, 0.146667, 0.0678989]], [0.21012, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("LWristYaw")
        times.append([0, 0.4, 0.48, 1.08, 1.76, 1.84, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[-1.45037, [3, -0.0133333, 0], [3, 0.133333, 0]], [-0.395814, [3, -0.133333, 0], [3, 0.0266667, 0]], [-0.395814, [3, -0.0266667, 0], [3, 0.2, 0]], [-0.420357, [3, -0.2, 0], [3, 0.226667, 0]], [-0.366667, [3, -0.226667, 0], [3, 0.0266667, 0]], [-0.395814, [3, -0.0266667, 0], [3, 0.226667, 0]], [-0.391212, [3, -0.226667, -0.00460241], [3, 0.16, 0.00324876]], [-0.366667, [3, -0.16, 0], [3, 0.173333, 0]], [-0.391212, [3, -0.173333, 0], [3, 0.28, 0]], [0.0827941, [3, -0.28, -0.0859035], [3, 0.04, 0.0122719]], [0.095066, [3, -0.04, 0], [3, 0.306667, 0]], [0.0827941, [3, -0.306667, 0], [3, 0.04, 0]], [0.095066, [3, -0.04, -0.00191264], [3, 0.146667, 0.00701303]], [0.109571, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("RAnklePitch")
        times.append([0, 0.4, 1.08, 1.76, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[-0.052114, [3, -0.0133333, 0], [3, 0.133333, 0]], [0.092082, [3, -0.133333, 0], [3, 0.226667, 0]], [0.082878, [3, -0.226667, 0], [3, 0.226667, 0]], [0.0859459, [3, -0.226667, 0], [3, 0.253333, 0]], [0.082878, [3, -0.253333, 0], [3, 0.16, 0]], [0.0859459, [3, -0.16, 0], [3, 0.173333, 0]], [0.082878, [3, -0.173333, 0.00306794], [3, 0.28, -0.0049559]], [0.029188, [3, -0.28, 0.0107378], [3, 0.04, -0.00153397]], [0.027654, [3, -0.04, 0], [3, 0.306667, 0]], [0.029188, [3, -0.306667, 0], [3, 0.04, 0]], [0.027654, [3, -0.04, 0], [3, 0.146667, 0]], [0.0829044, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("RAnkleRoll")
        times.append([0, 0.4, 1.08, 1.76, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[0.0966839, [3, -0.0133333, 0], [3, 0.133333, 0]], [0.26389, [3, -0.133333, 0], [3, 0.226667, 0]], [-0.0904641, [3, -0.226667, 0], [3, 0.226667, 0]], [0.251617, [3, -0.226667, 0], [3, 0.253333, 0]], [-0.0904641, [3, -0.253333, 0], [3, 0.16, 0]], [0.251617, [3, -0.16, 0], [3, 0.173333, 0]], [-0.0904641, [3, -0.173333, 0], [3, 0.28, 0]], [0.084412, [3, -0.28, 0], [3, 0.04, 0]], [0.084412, [3, -0.04, 0], [3, 0.306667, 0]], [0.084412, [3, -0.306667, 0], [3, 0.04, 0]], [0.084412, [3, -0.04, 0], [3, 0.146667, 0]], [0.106355, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("RElbowRoll")
        times.append([0, 0.4, 0.48, 0.8, 1.08, 1.4, 1.76, 1.84, 2.2, 2.52, 2.76, 3, 3.28, 3.52, 3.92, 4, 4.36, 4.48, 4.92, 5, 5.4, 5.52, 5.96])
        keys.append([[1.1205, [3, -0.0133333, 0], [3, 0.133333, 0]], [0.138102, [3, -0.133333, 0], [3, 0.0266667, 0]], [0.138102, [3, -0.0266667, 0], [3, 0.106667, 0]], [1.309, [3, -0.106667, 0], [3, 0.0933333, 0]], [0.257754, [3, -0.0933333, 0], [3, 0.106667, 0]], [1.4591, [3, -0.106667, 0], [3, 0.12, 0]], [0.165714, [3, -0.12, 0.124254], [3, 0.0266667, -0.027612]], [0.138102, [3, -0.0266667, 0], [3, 0.12, 0]], [1.309, [3, -0.12, 0], [3, 0.106667, 0]], [0.230143, [3, -0.106667, 0], [3, 0.08, 0]], [1.4591, [3, -0.08, 0], [3, 0.08, 0]], [0.165714, [3, -0.08, 0], [3, 0.0933333, 0]], [1.309, [3, -0.0933333, 0], [3, 0.08, 0]], [0.230143, [3, -0.08, 0], [3, 0.133333, 0]], [1.51669, [3, -0.133333, 0], [3, 0.0266667, 0]], [1.51669, [3, -0.0266667, 0], [3, 0.12, 0]], [0.055266, [3, -0.12, 0], [3, 0.04, 0]], [0.081344, [3, -0.04, -0.026078], [3, 0.146667, 0.0956194]], [1.12923, [3, -0.146667, 0], [3, 0.0266667, 0]], [1.12923, [3, -0.0266667, 0], [3, 0.133333, 0]], [0.055266, [3, -0.133333, 0], [3, 0.04, 0]], [0.081344, [3, -0.04, -0.026078], [3, 0.146667, 0.0956194]], [0.460254, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("RElbowYaw")
        times.append([0, 0.4, 0.48, 0.8, 1.08, 1.4, 1.76, 1.84, 2.2, 2.52, 2.76, 3, 3.28, 3.52, 3.92, 4, 4.36, 4.48, 4.92, 5, 5.4, 5.52, 5.96])
        keys.append([[0.567232, [3, -0.0133333, 0], [3, 0.133333, 0]], [-0.851412, [3, -0.133333, 0], [3, 0.0266667, 0]], [-0.851412, [3, -0.0266667, 0], [3, 0.106667, 0]], [-0.0750492, [3, -0.106667, -0.0839694], [3, 0.0933333, 0.0734732]], [-0.00157596, [3, -0.0933333, 0], [3, 0.106667, 0]], [-0.460767, [3, -0.106667, 0.132345], [3, 0.12, -0.148888]], [-0.845275, [3, -0.12, 0.0276146], [3, 0.0266667, -0.00613659]], [-0.851412, [3, -0.0266667, 0], [3, 0.12, 0]], [-0.0750492, [3, -0.12, -0.0723029], [3, 0.106667, 0.0642692]], [-0.01078, [3, -0.106667, 0], [3, 0.08, 0]], [-0.460767, [3, -0.08, 0.139083], [3, 0.08, -0.139083]], [-0.845275, [3, -0.08, 0], [3, 0.0933333, 0]], [-0.0750492, [3, -0.0933333, -0.0749807], [3, 0.08, 0.0642692]], [-0.01078, [3, -0.08, -0.0642692], [3, 0.133333, 0.107115]], [0.523599, [3, -0.133333, 0], [3, 0.0266667, 0]], [0.523599, [3, -0.0266667, 0], [3, 0.12, 0]], [-0.0429939, [3, -0.12, 0], [3, 0.04, 0]], [-0.0353239, [3, -0.04, -0.00767002], [3, 0.146667, 0.0281234]], [0.865683, [3, -0.146667, 0], [3, 0.0266667, 0]], [0.865683, [3, -0.0266667, 0], [3, 0.133333, 0]], [-0.0429939, [3, -0.133333, 0], [3, 0.04, 0]], [-0.0353239, [3, -0.04, -0.00767002], [3, 0.146667, 0.0281234]], [1.2554, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("RHand")
        times.append([0, 0.4, 0.48, 0.8, 1.08, 1.4, 1.76, 1.84, 2.2, 2.52, 2.76, 3, 3.28, 3.52, 3.92, 4, 4.36, 4.48, 4.92, 5, 5.4, 5.52, 5.96])
        keys.append([[0.5, [3, -0.0133333, 0], [3, 0.133333, 0]], [0.678, [3, -0.133333, 0], [3, 0.0266667, 0]], [0.678, [3, -0.0266667, 0], [3, 0.106667, 0]], [0.3, [3, -0.106667, 0], [3, 0.0933333, 0]], [0.6784, [3, -0.0933333, 0], [3, 0.106667, 0]], [0.3, [3, -0.106667, 0], [3, 0.12, 0]], [0.6768, [3, -0.12, -0.00539982], [3, 0.0266667, 0.00119996]], [0.678, [3, -0.0266667, 0], [3, 0.12, 0]], [0.3, [3, -0.12, 0], [3, 0.106667, 0]], [0.6776, [3, -0.106667, 0], [3, 0.08, 0]], [0.3, [3, -0.08, 0], [3, 0.08, 0]], [0.6768, [3, -0.08, 0], [3, 0.0933333, 0]], [0.3, [3, -0.0933333, 0], [3, 0.08, 0]], [0.6776, [3, -0.08, -0.0625], [3, 0.133333, 0.104167]], [0.8, [3, -0.133333, 0], [3, 0.0266667, 0]], [0.8, [3, -0.0266667, 0], [3, 0.12, 0]], [0.9108, [3, -0.12, 0], [3, 0.04, 0]], [0.908, [3, -0.04, 0.00279999], [3, 0.146667, -0.0102666]], [0.8, [3, -0.146667, 0], [3, 0.0266667, 0]], [0.8, [3, -0.0266667, 0], [3, 0.133333, 0]], [0.9108, [3, -0.133333, 0], [3, 0.04, 0]], [0.908, [3, -0.04, 0.00279999], [3, 0.146667, -0.0102666]], [0.352357, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("RHipPitch")
        times.append([0, 0.4, 1.08, 1.76, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[-0.177985, [3, -0.0133333, 0], [3, 0.133333, 0]], [0.101202, [3, -0.133333, -0.053974], [3, 0.226667, 0.0917558]], [0.259204, [3, -0.226667, -0.0138055], [3, 0.226667, 0.0138055]], [0.27301, [3, -0.226667, 0], [3, 0.253333, 0]], [0.259204, [3, -0.253333, 0], [3, 0.16, 0]], [0.27301, [3, -0.16, 0], [3, 0.173333, 0]], [0.259204, [3, -0.173333, 0], [3, 0.28, 0]], [0.345107, [3, -0.28, 0], [3, 0.04, 0]], [0.345107, [3, -0.04, 0], [3, 0.306667, 0]], [0.345107, [3, -0.306667, 0], [3, 0.04, 0]], [0.345107, [3, -0.04, 0], [3, 0.146667, 0]], [0.142653, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("RHipRoll")
        times.append([0, 0.4, 1.08, 1.76, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[-0.11961, [3, -0.0133333, 0], [3, 0.133333, 0]], [-0.297554, [3, -0.133333, 0], [3, 0.226667, 0]], [0.14117, [3, -0.226667, 0], [3, 0.226667, 0]], [-0.351244, [3, -0.226667, 0], [3, 0.253333, 0]], [0.14117, [3, -0.253333, 0], [3, 0.16, 0]], [-0.351244, [3, -0.16, 0], [3, 0.173333, 0]], [0.14117, [3, -0.173333, 0], [3, 0.28, 0]], [-0.107338, [3, -0.28, 0], [3, 0.04, 0]], [-0.107338, [3, -0.04, 0], [3, 0.306667, 0]], [-0.107338, [3, -0.306667, 0], [3, 0.04, 0]], [-0.107338, [3, -0.04, 0], [3, 0.146667, 0]], [-0.117168, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("RHipYawPitch")
        times.append([0.4, 5.96])
        keys.append([[-0.37272, [3, -0.146667, 0], [3, 1.85333, 0]], [-0.161593, [3, -1.85333, 0], [3, 0, 0]]])
        names.append("RKneePitch")
        times.append([0, 0.4, 1.08, 1.76, 2.52, 3, 3.52, 4.36, 4.48, 5.4, 5.52, 5.96])
        keys.append([[0.426494, [3, -0.0133333, 0], [3, 0.133333, 0]], [-0.0904641, [3, -0.133333, 0], [3, 0.226667, 0]], [-0.0904641, [3, -0.226667, 0], [3, 0.226667, 0]], [-0.091998, [3, -0.226667, 0], [3, 0.253333, 0]], [-0.0904641, [3, -0.253333, 0], [3, 0.16, 0]], [-0.091998, [3, -0.16, 0], [3, 0.173333, 0]], [-0.0904641, [3, -0.173333, 0], [3, 0.28, 0]], [-0.0923279, [3, -0.28, 0], [3, 0.04, 0]], [-0.0923279, [3, -0.04, 0], [3, 0.306667, 0]], [-0.0923279, [3, -0.306667, 0], [3, 0.04, 0]], [-0.0923279, [3, -0.04, 0], [3, 0.146667, 0]], [-0.0853082, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("RShoulderPitch")
        times.append([0.4, 0.48, 1.08, 1.76, 1.84, 2.52, 3, 3.52, 3.92, 4, 4.36, 4.48, 4.92, 5, 5.4, 5.52, 5.96])
        keys.append([[-1.19188, [3, -0.146667, 0], [3, 0.0266667, 0]], [-1.19188, [3, -0.0266667, 0], [3, 0.2, 0]], [0.995607, [3, -0.2, 0], [3, 0.226667, 0]], [-1.15506, [3, -0.226667, 0.312935], [3, 0.0266667, -0.0368159]], [-1.19188, [3, -0.0266667, 0], [3, 0.226667, 0]], [1.00481, [3, -0.226667, 0], [3, 0.16, 0]], [-1.15506, [3, -0.16, 0], [3, 0.173333, 0]], [1.00481, [3, -0.173333, 0], [3, 0.133333, 0]], [0.390954, [3, -0.133333, 0], [3, 0.0266667, 0]], [0.390954, [3, -0.0266667, 0], [3, 0.12, 0]], [-0.0536481, [3, -0.12, 0], [3, 0.04, 0]], [0.021518, [3, -0.04, 0], [3, 0.146667, 0]], [-0.390954, [3, -0.146667, 0], [3, 0.0266667, 0]], [-0.390954, [3, -0.0266667, 0], [3, 0.133333, 0]], [-0.0536481, [3, -0.133333, -0.105762], [3, 0.04, 0.0317286]], [0.021518, [3, -0.04, -0.0751661], [3, 0.146667, 0.275609]], [1.45752, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("RShoulderRoll")
        times.append([0, 0.4, 0.48, 0.8, 1.08, 1.4, 1.76, 1.84, 2.2, 2.52, 2.76, 3, 3.28, 3.52, 3.92, 4, 4.36, 4.48, 4.92, 5, 5.4, 5.52, 5.96])
        keys.append([[-0.670206, [3, -0.0133333, 0], [3, 0.133333, 0]], [-0.328317, [3, -0.133333, 0], [3, 0.0266667, 0]], [-0.328317, [3, -0.0266667, 0], [3, 0.106667, 0]], [-0.595157, [3, -0.106667, 0], [3, 0.0933333, 0]], [0.314159, [3, -0.0933333, 0], [3, 0.106667, 0]], [-0.595157, [3, -0.106667, 0], [3, 0.12, 0]], [-0.331386, [3, -0.12, -0.0138073], [3, 0.0266667, 0.00306829]], [-0.328317, [3, -0.0266667, 0], [3, 0.12, 0]], [-0.595157, [3, -0.12, 0], [3, 0.106667, 0]], [0.276078, [3, -0.106667, 0], [3, 0.08, 0]], [-0.595157, [3, -0.08, 0], [3, 0.08, 0]], [-0.331386, [3, -0.08, 0], [3, 0.0933333, 0]], [-0.595157, [3, -0.0933333, 0], [3, 0.08, 0]], [0.276078, [3, -0.08, 0], [3, 0.133333, 0]], [-0.670206, [3, -0.133333, 0], [3, 0.0266667, 0]], [-0.670206, [3, -0.0266667, 0], [3, 0.12, 0]], [-0.0890139, [3, -0.12, 0], [3, 0.04, 0]], [-0.105888, [3, -0.04, 0.016874], [3, 0.146667, -0.0618714]], [-0.359538, [3, -0.146667, 0], [3, 0.0266667, 0]], [-0.359538, [3, -0.0266667, 0], [3, 0.133333, 0]], [-0.0890139, [3, -0.133333, 0], [3, 0.04, 0]], [-0.105888, [3, -0.04, 0.00790382], [3, 0.146667, -0.0289807]], [-0.199667, [3, -0.146667, 0], [3, 0, 0]]])
        names.append("RWristYaw")
        times.append([0, 0.4, 0.48, 1.08, 1.76, 1.84, 2.52, 3, 3.52, 3.92, 4, 4.36, 4.48, 4.92, 5, 5.4, 5.52, 5.96])
        keys.append([[1.39277, [3, -0.0133333, 0], [3, 0.133333, 0]], [0.107338, [3, -0.133333, 0], [3, 0.0266667, 0]], [0.107338, [3, -0.0266667, 0], [3, 0.2, 0]], [0.400331, [3, -0.2, 0], [3, 0.226667, 0]], [0.115008, [3, -0.226667, 0.0651952], [3, 0.0266667, -0.00767002]], [0.107338, [3, -0.0266667, 0], [3, 0.226667, 0]], [0.392662, [3, -0.226667, 0], [3, 0.16, 0]], [0.115008, [3, -0.16, 0], [3, 0.173333, 0]], [0.392662, [3, -0.173333, 0], [3, 0.133333, 0]], [0.158825, [3, -0.133333, 0], [3, 0.0266667, 0]], [0.158825, [3, -0.0266667, 0], [3, 0.12, 0]], [0.013764, [3, -0.12, 0], [3, 0.04, 0]], [0.022968, [3, -0.04, -0.00920398], [3, 0.146667, 0.0337479]], [0.158825, [3, -0.146667, 0], [3, 0.0266667, 0]], [0.158825, [3, -0.0266667, 0], [3, 0.133333, 0]], [0.013764, [3, -0.133333, 0], [3, 0.04, 0]], [0.022968, [3, -0.04, -0.00862312], [3, 0.146667, 0.0316181]], [0.134488, [3, -0.146667, 0], [3, 0, 0]]])
        try:
          # uncomment the following line and modify the IP if you use this script outside Choregraphe.
          # motion = ALProxy("ALMotion", IP, 9559)
          motion = ALProxy("ALMotion")
          motion.angleInterpolationBezier(names, times, keys)
        except BaseException, err:
          print err
################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################
    def fist(self):
        # Choregraphe bezier export in Python.
        names = list()
        times = list()
        keys = list()
        names.append("HeadPitch")
        times.append([0.96, 1.44, 1.96, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[0.0872665, [3, -0.333333, 0], [3, 0.16, 0]], [-0.349066, [3, -0.16, 0], [3, 0.173333, 0]], [0.0872665, [3, -0.173333, 0], [3, 0.16, 0]], [-0.349066, [3, -0.16, 0], [3, 0.173333, 0]], [0.0872665, [3, -0.173333, 0], [3, 0.16, 0]], [-0.349066, [3, -0.16, 0], [3, 0.173333, 0]], [0.0872665, [3, -0.173333, 0], [3, 0.173333, 0]], [-0.349066, [3, -0.173333, 0], [3, 0.36, 0]], [-0.177255, [3, -0.36, 0], [3, 0, 0]]])
        names.append("HeadYaw")
        times.append([1.44, 2.44, 3.44, 4.48, 5.56])
        keys.append([[0, [3, -0.493333, 0], [3, 0.333333, 0]], [0, [3, -0.333333, 0], [3, 0.333333, 0]], [0, [3, -0.333333, 0], [3, 0.346667, 0]], [0, [3, -0.346667, 0], [3, 0.36, 0]], [-0.00367428, [3, -0.36, 0], [3, 0, 0]]])
        names.append("LAnklePitch")
        times.append([1.44, 2.44, 3.44, 4.48, 5.56])
        keys.append([[0.0866825, [3, -0.493333, 0], [3, 0.333333, 0]], [0.0866825, [3, -0.333333, 0], [3, 0.333333, 0]], [0.0866825, [3, -0.333333, 0], [3, 0.346667, 0]], [0.0866825, [3, -0.346667, 0], [3, 0.36, 0]], [0.0806126, [3, -0.36, 0], [3, 0, 0]]])
        names.append("LAnkleRoll")
        times.append([1.44, 2.44, 3.44, 4.48, 5.56])
        keys.append([[-0.102616, [3, -0.493333, 0], [3, 0.333333, 0]], [-0.102616, [3, -0.333333, 0], [3, 0.333333, 0]], [-0.105742, [3, -0.333333, 0], [3, 0.346667, 0]], [-0.105742, [3, -0.346667, 0], [3, 0.36, 0]], [-0.106852, [3, -0.36, 0], [3, 0, 0]]])
        names.append("LElbowRoll")
        times.append([0.96, 1.44, 1.96, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[-0.0663225, [3, -0.333333, 0], [3, 0.16, 0]], [-0.0432081, [3, -0.16, -0.00502655], [3, 0.173333, 0.00544543]], [-0.0349066, [3, -0.173333, 0], [3, 0.16, 0]], [-0.0432035, [3, -0.16, 0.00829695], [3, 0.173333, -0.00898836]], [-1.54462, [3, -0.173333, 0], [3, 0.16, 0]], [-0.0383972, [3, -0.16, 0], [3, 0.173333, 0]], [-1.54462, [3, -0.173333, 0], [3, 0.173333, 0]], [-0.261843, [3, -0.173333, 0], [3, 0.36, 0]], [-0.420681, [3, -0.36, 0], [3, 0, 0]]])
        names.append("LElbowYaw")
        times.append([0.96, 1.44, 1.96, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[-0.521853, [3, -0.333333, 0], [3, 0.16, 0]], [-0.52604, [3, -0.16, 0], [3, 0.173333, 0]], [-0.521853, [3, -0.173333, -0.00367294], [3, 0.16, 0.00339041]], [-0.50485, [3, -0.16, 0], [3, 0.173333, 0]], [-1.54636, [3, -0.173333, 0], [3, 0.16, 0]], [-1.40709, [3, -0.16, 0], [3, 0.173333, 0]], [-1.54636, [3, -0.173333, 0], [3, 0.173333, 0]], [-1.45644, [3, -0.173333, -0.0371788], [3, 0.36, 0.0772175]], [-1.20317, [3, -0.36, 0], [3, 0, 0]]])
        names.append("LHand")
        times.append([0.96, 1.44, 1.96, 2.44, 3.44, 4.48, 5.56])
        keys.append([[0, [3, -0.333333, 0], [3, 0.16, 0]], [0, [3, -0.16, 0], [3, 0.173333, 0]], [0, [3, -0.173333, 0], [3, 0.16, 0]], [0.00250534, [3, -0.16, 0], [3, 0.333333, 0]], [0, [3, -0.333333, 0], [3, 0.346667, 0]], [0.00984604, [3, -0.346667, -0.00984604], [3, 0.36, 0.0102247]], [0.3, [3, -0.36, 0], [3, 0, 0]]])
        names.append("LHipPitch")
        times.append([1.44, 2.44, 3.44, 4.48, 5.56])
        keys.append([[0.123171, [3, -0.493333, 0], [3, 0.333333, 0]], [0.123171, [3, -0.333333, 0], [3, 0.333333, 0]], [0.123172, [3, -0.333333, 0], [3, 0.346667, 0]], [0.123172, [3, -0.346667, 0], [3, 0.36, 0]], [0.125733, [3, -0.36, 0], [3, 0, 0]]])
        names.append("LHipRoll")
        times.append([1.44, 2.44, 3.44, 4.48, 5.56])
        keys.append([[0.112188, [3, -0.493333, 0], [3, 0.333333, 0]], [0.112188, [3, -0.333333, 0], [3, 0.333333, 0]], [0.112183, [3, -0.333333, 0], [3, 0.346667, 0]], [0.112183, [3, -0.346667, 0], [3, 0.36, 0]], [0.109581, [3, -0.36, 0], [3, 0, 0]]])
        names.append("LHipYawPitch")
        times.append([0.96, 1.44, 1.96, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[-0.126371, [3, -0.333333, 0], [3, 0.16, 0]], [-0.216442, [3, -0.16, 0], [3, 0.173333, 0]], [-0.145423, [3, -0.173333, 0], [3, 0.16, 0]], [-0.262185, [3, -0.16, 0], [3, 0.173333, 0]], [-0.112562, [3, -0.173333, 0], [3, 0.16, 0]], [-0.29203, [3, -0.16, 0], [3, 0.173333, 0]], [-0.163523, [3, -0.173333, 0], [3, 0.173333, 0]], [-0.252137, [3, -0.173333, 0], [3, 0.36, 0]], [-0.173337, [3, -0.36, 0], [3, 0, 0]]])
        names.append("LKneePitch")
        times.append([1.44, 2.44, 3.44, 4.48, 5.56])
        keys.append([[-0.0872551, [3, -0.493333, 0], [3, 0.333333, 0]], [-0.0872551, [3, -0.333333, 0], [3, 0.333333, 0]], [-0.0872551, [3, -0.333333, 0], [3, 0.346667, 0]], [-0.0872551, [3, -0.346667, 0], [3, 0.36, 0]], [-0.0830429, [3, -0.36, 0], [3, 0, 0]]])
        names.append("LShoulderPitch")
        times.append([0.96, 1.44, 1.96, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[0.287979, [3, -0.333333, 0], [3, 0.16, 0]], [0.230383, [3, -0.16, 0], [3, 0.173333, 0]], [0.287979, [3, -0.173333, 0], [3, 0.16, 0]], [0.230057, [3, -0.16, 0], [3, 0.173333, 0]], [0.912807, [3, -0.173333, 0], [3, 0.16, 0]], [-0.0523599, [3, -0.16, 0], [3, 0.173333, 0]], [0.912807, [3, -0.173333, 0], [3, 0.173333, 0]], [0.651643, [3, -0.173333, 0], [3, 0.36, 0]], [1.43703, [3, -0.36, 0], [3, 0, 0]]])
        names.append("LShoulderRoll")
        times.append([0.96, 1.44, 1.96, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[-0.139626, [3, -0.333333, 0], [3, 0.16, 0]], [-0.224985, [3, -0.16, 0], [3, 0.173333, 0]], [-0.139626, [3, -0.173333, 0], [3, 0.16, 0]], [-0.21892, [3, -0.16, 0], [3, 0.173333, 0]], [0.0366519, [3, -0.173333, 0], [3, 0.16, 0]], [-0.305527, [3, -0.16, 0], [3, 0.173333, 0]], [0.0366519, [3, -0.173333, 0], [3, 0.173333, 0]], [-0.281033, [3, -0.173333, 0], [3, 0.36, 0]], [0.221261, [3, -0.36, 0], [3, 0, 0]]])
        names.append("LWristYaw")
        times.append([0.96, 1.44, 1.96, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[0.588176, [3, -0.333333, 0], [3, 0.16, 0]], [0.587438, [3, -0.16, 0], [3, 0.173333, 0]], [0.588176, [3, -0.173333, 0], [3, 0.16, 0]], [0.584392, [3, -0.16, 0.00378389], [3, 0.173333, -0.00409921]], [-1.1781, [3, -0.173333, 0], [3, 0.16, 0]], [1.09158, [3, -0.16, 0], [3, 0.173333, 0]], [-1.1781, [3, -0.173333, 0], [3, 0.173333, 0]], [1.50344, [3, -0.173333, 0], [3, 0.36, 0]], [0.101113, [3, -0.36, 0], [3, 0, 0]]])
        names.append("RAnklePitch")
        times.append([1.44, 2.44, 3.44, 4.48, 5.56])
        keys.append([[0.0866825, [3, -0.493333, 0], [3, 0.333333, 0]], [0.0866825, [3, -0.333333, 0], [3, 0.333333, 0]], [0.0866825, [3, -0.333333, 0], [3, 0.346667, 0]], [0.0866825, [3, -0.346667, 0], [3, 0.36, 0]], [0.0787795, [3, -0.36, 0], [3, 0, 0]]])
        names.append("RAnkleRoll")
        times.append([1.44, 2.44, 2.96, 3.44, 4.48, 5.56])
        keys.append([[0.105742, [3, -0.493333, 0], [3, 0.333333, 0]], [0.105742, [3, -0.333333, 0], [3, 0.173333, 0]], [0.0872665, [3, -0.173333, 0], [3, 0.16, 0]], [0.102616, [3, -0.16, 0], [3, 0.346667, 0]], [0.102616, [3, -0.346667, 0], [3, 0.36, 0]], [0.10102, [3, -0.36, 0], [3, 0, 0]]])
        names.append("RElbowRoll")
        times.append([0.96, 1.44, 1.96, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[1.54462, [3, -0.333333, 0], [3, 0.16, 0]], [0.0383972, [3, -0.16, 0], [3, 0.173333, 0]], [1.54462, [3, -0.173333, 0], [3, 0.16, 0]], [0.261843, [3, -0.16, 0.20948], [3, 0.173333, -0.226936]], [0.0349066, [3, -0.173333, 0], [3, 0.16, 0]], [0.0432081, [3, -0.16, 0], [3, 0.173333, 0]], [0.0349066, [3, -0.173333, 0], [3, 0.173333, 0]], [0.0432035, [3, -0.173333, -0.00829695], [3, 0.36, 0.0172321]], [0.415611, [3, -0.36, 0], [3, 0, 0]]])
        names.append("RElbowYaw")
        times.append([0.96, 1.44, 1.96, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[1.54636, [3, -0.333333, 0], [3, 0.16, 0]], [1.40709, [3, -0.16, 0], [3, 0.173333, 0]], [1.54636, [3, -0.173333, 0], [3, 0.16, 0]], [1.45644, [3, -0.16, 0.0899246], [3, 0.173333, -0.0974183]], [0.521853, [3, -0.173333, 0], [3, 0.16, 0]], [0.52604, [3, -0.16, 0], [3, 0.173333, 0]], [0.521853, [3, -0.173333, 0.00353167], [3, 0.173333, -0.00353167]], [0.50485, [3, -0.173333, 0], [3, 0.36, 0]], [1.19598, [3, -0.36, 0], [3, 0, 0]]])
        names.append("RHand")
        times.append([0.96, 1.44, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[0, [3, -0.333333, 0], [3, 0.16, 0]], [0, [3, -0.16, 0], [3, 0.333333, 0]], [0.00984604, [3, -0.333333, 0], [3, 0.173333, 0]], [0, [3, -0.173333, 0], [3, 0.16, 0]], [0, [3, -0.16, 0], [3, 0.173333, 0]], [0, [3, -0.173333, 0], [3, 0.173333, 0]], [0.00250534, [3, -0.173333, -0.00250534], [3, 0.36, 0.0052034]], [0.3, [3, -0.36, 0], [3, 0, 0]]])
        names.append("RHipPitch")
        times.append([1.44, 2.44, 3.44, 4.48, 5.56])
        keys.append([[0.123172, [3, -0.493333, 0], [3, 0.333333, 0]], [0.123172, [3, -0.333333, 0], [3, 0.333333, 0]], [0.123171, [3, -0.333333, 0], [3, 0.346667, 0]], [0.123171, [3, -0.346667, 0], [3, 0.36, 0]], [0.127247, [3, -0.36, 0], [3, 0, 0]]])
        names.append("RHipRoll")
        times.append([1.44, 2.44, 3.44, 4.48, 5.56])
        keys.append([[-0.112183, [3, -0.493333, 0], [3, 0.333333, 0]], [-0.112183, [3, -0.333333, 0], [3, 0.333333, 0]], [-0.112188, [3, -0.333333, 0], [3, 0.346667, 0]], [-0.112188, [3, -0.346667, 0], [3, 0.36, 0]], [-0.109595, [3, -0.36, 0], [3, 0, 0]]])
        names.append("RHipYawPitch")
        times.append([0.96, 1.44, 1.96, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[-0.126371, [3, -0.333333, 0], [3, 0.16, 0]], [-0.216442, [3, -0.16, 0], [3, 0.173333, 0]], [-0.145423, [3, -0.173333, 0], [3, 0.16, 0]], [-0.262185, [3, -0.16, 0], [3, 0.173333, 0]], [-0.112562, [3, -0.173333, 0], [3, 0.16, 0]], [-0.29203, [3, -0.16, 0], [3, 0.173333, 0]], [-0.163523, [3, -0.173333, 0], [3, 0.173333, 0]], [-0.252137, [3, -0.173333, 0], [3, 0.36, 0]], [-0.173337, [3, -0.36, 0], [3, 0, 0]]])
        names.append("RKneePitch")
        times.append([1.44, 2.44, 3.44, 4.48, 5.56])
        keys.append([[-0.0872551, [3, -0.493333, 0], [3, 0.333333, 0]], [-0.0872551, [3, -0.333333, 0], [3, 0.333333, 0]], [-0.0872551, [3, -0.333333, 0], [3, 0.346667, 0]], [-0.0872551, [3, -0.346667, 0], [3, 0.36, 0]], [-0.0869268, [3, -0.36, 0], [3, 0, 0]]])
        names.append("RShoulderPitch")
        times.append([0.96, 1.44, 1.96, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[0.912807, [3, -0.333333, 0], [3, 0.16, 0]], [-0.0523599, [3, -0.16, 0], [3, 0.173333, 0]], [0.912807, [3, -0.173333, 0], [3, 0.16, 0]], [0.651643, [3, -0.16, 0.0999725], [3, 0.173333, -0.108303]], [0.287979, [3, -0.173333, 0.0623955], [3, 0.16, -0.0575959]], [0.230383, [3, -0.16, 0], [3, 0.173333, 0]], [0.287979, [3, -0.173333, 0], [3, 0.173333, 0]], [0.230057, [3, -0.173333, 0], [3, 0.36, 0]], [1.4376, [3, -0.36, 0], [3, 0, 0]]])
        names.append("RShoulderRoll")
        times.append([0.96, 1.44, 1.96, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[-0.0366519, [3, -0.333333, 0], [3, 0.16, 0]], [0.305527, [3, -0.16, 0], [3, 0.173333, 0]], [-0.0366519, [3, -0.173333, 0], [3, 0.16, 0]], [0.281033, [3, -0.16, 0], [3, 0.173333, 0]], [0.139626, [3, -0.173333, 0], [3, 0.16, 0]], [0.224985, [3, -0.16, 0], [3, 0.173333, 0]], [0.139626, [3, -0.173333, 0], [3, 0.173333, 0]], [0.21892, [3, -0.173333, 0], [3, 0.36, 0]], [-0.216046, [3, -0.36, 0], [3, 0, 0]]])
        names.append("RWristYaw")
        times.append([0.96, 1.44, 1.96, 2.44, 2.96, 3.44, 3.96, 4.48, 5.56])
        keys.append([[1.1781, [3, -0.333333, 0], [3, 0.16, 0]], [-1.09158, [3, -0.16, 0], [3, 0.173333, 0]], [1.1781, [3, -0.173333, 0], [3, 0.16, 0]], [-1.50344, [3, -0.16, 0], [3, 0.173333, 0]], [-0.588176, [3, -0.173333, -0.000799819], [3, 0.16, 0.000738295]], [-0.587438, [3, -0.16, 0], [3, 0.173333, 0]], [-0.588176, [3, -0.173333, 0], [3, 0.173333, 0]], [-0.584392, [3, -0.173333, -0.00378389], [3, 0.36, 0.00785884]], [0.0989295, [3, -0.36, 0], [3, 0, 0]]])
        try:
          # uncomment the following line and modify the IP if you use this script outside Choregraphe.
          # motion = ALProxy("ALMotion", IP, 9559)
          motion = ALProxy("ALMotion")
          motion.angleInterpolationBezier(names, times, keys)
        except BaseException, err:
          print err
##################################################################################################################################################################################################################################################################################################################################################################################################################################
    def hide(self):
        # Choregraphe bezier export in Python.
        names = list()
        times = list()
        keys = list()
        names.append("HeadPitch")
        times.append([0.96, 1.96, 2.96, 4.96])
        keys.append([[-0.160616, [3, -0.333333, 0], [3, 0.333333, 0]], [0.0872665, [3, -0.333333, 0], [3, 0.333333, 0]], [-0.349066, [3, -0.333333, 0], [3, 0.666667, 0]], [-0.349066, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("HeadYaw")
        times.append([0.96, 1.96, 2.96, 4.96])
        keys.append([[0, [3, -0.333333, 0], [3, 0.333333, 0]], [0, [3, -0.333333, 0], [3, 0.333333, 0]], [0, [3, -0.333333, 0], [3, 0.666667, 0]], [0, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("LAnklePitch")
        times.append([0.96, 2.96, 4.96])
        keys.append([[0.0866825, [3, -0.333333, 0], [3, 0.666667, 0]], [0.0866825, [3, -0.666667, 0], [3, 0.666667, 0]], [0.0866825, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("LAnkleRoll")
        times.append([0.96, 2.96, 4.96])
        keys.append([[-0.102616, [3, -0.333333, 0], [3, 0.666667, 0]], [-0.102616, [3, -0.666667, 0], [3, 0.666667, 0]], [-0.102616, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("LElbowRoll")
        times.append([0.96, 1.96, 2.96, 3.96, 4.96])
        keys.append([[-0.4249, [3, -0.333333, 0], [3, 0.333333, 0]], [-1.54462, [3, -0.333333, 0], [3, 0.333333, 0]], [-1.54462, [3, -0.333333, 0], [3, 0.333333, 0]], [-1.54462, [3, -0.333333, 0], [3, 0.333333, 0]], [-1.54309, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LElbowYaw")
        times.append([0.96, 1.96, 2.96, 3.96, 4.96])
        keys.append([[-1.20864, [3, -0.333333, 0], [3, 0.333333, 0]], [-1.19031, [3, -0.333333, -0.0183208], [3, 0.333333, 0.0183208]], [-0.174533, [3, -0.333333, 0], [3, 0.333333, 0]], [-1.19031, [3, -0.333333, 0.308059], [3, 0.333333, -0.308059]], [-2.02289, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LHand")
        times.append([0.96, 2.96, 4.96])
        keys.append([[0.307763, [3, -0.333333, 0], [3, 0.666667, 0]], [1, [3, -0.666667, 0], [3, 0.666667, 0]], [0.478009, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("LHipPitch")
        times.append([0.96, 2.96, 4.96])
        keys.append([[0.123171, [3, -0.333333, 0], [3, 0.666667, 0]], [0.123171, [3, -0.666667, 0], [3, 0.666667, 0]], [0.123171, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("LHipRoll")
        times.append([0.96, 2.96, 4.96])
        keys.append([[0.11865, [3, -0.333333, 0], [3, 0.666667, 0]], [0.11865, [3, -0.666667, 0], [3, 0.666667, 0]], [0.112188, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("LHipYawPitch")
        times.append([0.96, 2.96, 4.96])
        keys.append([[-0.170194, [3, -0.333333, 0], [3, 0.666667, 0]], [-0.170194, [3, -0.666667, 0], [3, 0.666667, 0]], [-0.170695, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("LKneePitch")
        times.append([0.96, 2.96, 4.96])
        keys.append([[-0.0872551, [3, -0.333333, 0], [3, 0.666667, 0]], [-0.0872551, [3, -0.666667, 0], [3, 0.666667, 0]], [-0.0872551, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("LShoulderPitch")
        times.append([0.96, 1.96, 2.96, 3.96, 4.96])
        keys.append([[1.43298, [3, -0.333333, 0], [3, 0.333333, 0]], [0.457276, [3, -0.333333, 0], [3, 0.333333, 0]], [0.968658, [3, -0.333333, 0], [3, 0.333333, 0]], [0.457276, [3, -0.333333, 0], [3, 0.333333, 0]], [0.968689, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LShoulderRoll")
        times.append([0.96, 1.96, 2.96, 3.96, 4.96])
        keys.append([[0.217049, [3, -0.333333, 0], [3, 0.333333, 0]], [-0.314159, [3, -0.333333, 0], [3, 0.333333, 0]], [-0.314159, [3, -0.333333, 0], [3, 0.333333, 0]], [-0.314159, [3, -0.333333, 0], [3, 0.333333, 0]], [0.928599, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LWristYaw")
        times.append([0.96, 1.96, 2.96, 3.96, 4.96])
        keys.append([[0.100732, [3, -0.333333, 0], [3, 0.333333, 0]], [-1.04196, [3, -0.333333, 0], [3, 0.333333, 0]], [-0.491235, [3, -0.333333, 0], [3, 0.333333, 0]], [-1.04196, [3, -0.333333, 0.221984], [3, 0.333333, -0.221984]], [-1.82314, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RAnklePitch")
        times.append([0.96, 2.96, 4.96])
        keys.append([[0.0866825, [3, -0.333333, 0], [3, 0.666667, 0]], [0.0866825, [3, -0.666667, 0], [3, 0.666667, 0]], [0.0866825, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("RAnkleRoll")
        times.append([0.96, 2.96, 4.96])
        keys.append([[0.105742, [3, -0.333333, 0], [3, 0.666667, 0]], [0.105742, [3, -0.666667, 0], [3, 0.666667, 0]], [0.105742, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("RElbowRoll")
        times.append([0.96, 1.96, 2.96, 3.96, 4.96])
        keys.append([[0.415757, [3, -0.333333, 0], [3, 0.333333, 0]], [1.54462, [3, -0.333333, 0], [3, 0.333333, 0]], [1.54462, [3, -0.333333, 0], [3, 0.333333, 0]], [1.54462, [3, -0.333333, 0], [3, 0.333333, 0]], [1.34004, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RElbowYaw")
        times.append([0.96, 1.96, 2.96, 3.96, 4.96])
        keys.append([[1.2087, [3, -0.333333, 0], [3, 0.333333, 0]], [1.13097, [3, -0.333333, 0], [3, 0.333333, 0]], [2.02807, [3, -0.333333, 0], [3, 0.333333, 0]], [1.13097, [3, -0.333333, 0.310471], [3, 0.333333, -0.310471]], [0.165244, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RHand")
        times.append([0.96, 2.96, 4.96])
        keys.append([[0.307833, [3, -0.333333, 0], [3, 0.666667, 0]], [0.47, [3, -0.666667, -0.0486945], [3, 0.666667, 0.0486945]], [0.6, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("RHipPitch")
        times.append([0.96, 2.96, 4.96])
        keys.append([[0.123172, [3, -0.333333, 0], [3, 0.666667, 0]], [0.123172, [3, -0.666667, 0], [3, 0.666667, 0]], [0.123172, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("RHipRoll")
        times.append([0.96, 2.96, 4.96])
        keys.append([[-0.118644, [3, -0.333333, 0], [3, 0.666667, 0]], [-0.118644, [3, -0.666667, 0], [3, 0.666667, 0]], [-0.112183, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("RHipYawPitch")
        times.append([0.96, 2.96, 4.96])
        keys.append([[-0.170194, [3, -0.333333, 0], [3, 0.666667, 0]], [-0.170194, [3, -0.666667, 0], [3, 0.666667, 0]], [-0.170695, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("RKneePitch")
        times.append([0.96, 2.96, 4.96])
        keys.append([[-0.0872551, [3, -0.333333, 0], [3, 0.666667, 0]], [-0.0872551, [3, -0.666667, 0], [3, 0.666667, 0]], [-0.0872551, [3, -0.666667, 0], [3, 0, 0]]])
        names.append("RShoulderPitch")
        times.append([0.96, 1.96, 2.96, 3.96, 4.96])
        keys.append([[1.43733, [3, -0.333333, 0], [3, 0.333333, 0]], [0.467748, [3, -0.333333, 0], [3, 0.333333, 0]], [0.968658, [3, -0.333333, 0], [3, 0.333333, 0]], [0.467748, [3, -0.333333, 0], [3, 0.333333, 0]], [0.820788, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RShoulderRoll")
        times.append([0.96, 1.96, 2.96, 3.96, 4.96])
        keys.append([[-0.216857, [3, -0.333333, 0], [3, 0.333333, 0]], [0.314159, [3, -0.333333, 0], [3, 0.333333, 0]], [-0.93026, [3, -0.333333, 0], [3, 0.333333, 0]], [0.314159, [3, -0.333333, 0], [3, 0.333333, 0]], [0.0553695, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RWristYaw")
        times.append([0.96, 1.96, 2.96, 3.96, 4.96])
        keys.append([[0.0977473, [3, -0.333333, 0], [3, 0.333333, 0]], [1.1781, [3, -0.333333, -0.287687], [3, 0.333333, 0.287687]], [1.82387, [3, -0.333333, 0], [3, 0.333333, 0]], [1.1781, [3, -0.333333, 0.263254], [3, 0.333333, -0.263254]], [0.244348, [3, -0.333333, 0], [3, 0, 0]]])
        try:
          # uncomment the following line and modify the IP if you use this script outside Choregraphe.
          # motion = ALProxy("ALMotion", IP, 9559)
          motion = ALProxy("ALMotion")
          motion.angleInterpolationBezier(names, times, keys)
        except BaseException, err:
          print err
##################################################################################################################################################################################################################################################################################################################################################################################################################################
    def star(self):
        # Choregraphe bezier export in Python.
        from naoqi import ALProxy
        names = list()
        times = list()
        keys = list()
        names.append("HeadPitch")
        times.append([0.56, 1.16, 1.76, 2.36, 2.96])
        keys.append([[-0.174533, [3, -0.2, 0], [3, 0.2, 0]], [0.349066, [3, -0.2, 0], [3, 0.2, 0]], [-0.174533, [3, -0.2, 0], [3, 0.2, 0]], [0.349066, [3, -0.2, 0], [3, 0.2, 0]], [0.00602814, [3, -0.2, 0], [3, 0, 0]]])
        names.append("HeadYaw")
        times.append([1.16, 2.36, 2.96])
        keys.append([[0, [3, -0.4, 0], [3, 0.4, 0]], [0, [3, -0.4, 0], [3, 0.2, 0]], [0, [3, -0.2, 0], [3, 0, 0]]])
        names.append("LAnklePitch")
        times.append([0.56, 1.16, 1.76, 2.36, 2.96])
        keys.append([[-0.349066, [3, -0.2, 0], [3, 0.2, 0]], [0.0866825, [3, -0.2, 0], [3, 0.2, 0]], [-0.349066, [3, -0.2, 0], [3, 0.2, 0]], [0.0866825, [3, -0.2, 0], [3, 0.2, 0]], [-0.342458, [3, -0.2, 0], [3, 0, 0]]])
        names.append("LAnkleRoll")
        times.append([1.16, 2.36, 2.96])
        keys.append([[-0.101229, [3, -0.4, 0], [3, 0.4, 0]], [-0.101229, [3, -0.4, 0], [3, 0.2, 0]], [-0.000791166, [3, -0.2, 0], [3, 0, 0]]])
        names.append("LElbowRoll")
        times.append([1.16, 2.36, 2.96])
        keys.append([[-1.54462, [3, -0.4, 0], [3, 0.4, 0]], [-1.54462, [3, -0.4, 0], [3, 0.2, 0]], [-1.01186, [3, -0.2, 0], [3, 0, 0]]])
        names.append("LElbowYaw")
        times.append([0.56, 1.16, 1.76, 2.36, 2.96])
        keys.append([[-1.5708, [3, -0.2, 0], [3, 0.2, 0]], [1.5708, [3, -0.2, 0], [3, 0.2, 0]], [-1.5708, [3, -0.2, 0], [3, 0.2, 0]], [1.5708, [3, -0.2, 0], [3, 0.2, 0]], [-1.38976, [3, -0.2, 0], [3, 0, 0]]])
        names.append("LHand")
        times.append([1.16, 2.36, 2.96])
        keys.append([[1, [3, -0.4, 0], [3, 0.4, 0]], [1, [3, -0.4, 0], [3, 0.2, 0]], [0.255862, [3, -0.2, 0], [3, 0, 0]]])
        names.append("LHipPitch")
        times.append([0.56, 1.16, 1.76, 2.36, 2.96])
        keys.append([[-0.349066, [3, -0.2, 0], [3, 0.2, 0]], [0.123918, [3, -0.2, 0], [3, 0.2, 0]], [-0.349066, [3, -0.2, 0], [3, 0.2, 0]], [0.123918, [3, -0.2, 0], [3, 0.2, 0]], [-0.440088, [3, -0.2, 0], [3, 0, 0]]])
        names.append("LHipRoll")
        times.append([1.16, 2.36, 2.96])
        keys.append([[0.118682, [3, -0.4, 0], [3, 0.4, 0]], [0.118682, [3, -0.4, 0], [3, 0.2, 0]], [0.00774902, [3, -0.2, 0], [3, 0, 0]]])
        names.append("LHipYawPitch")
        times.append([1.16, 2.36, 2.96])
        keys.append([[-0.171042, [3, -0.4, 0], [3, 0.4, 0]], [-0.171042, [3, -0.4, 0], [3, 0.2, 0]], [-0.0029538, [3, -0.2, 0], [3, 0, 0]]])
        names.append("LKneePitch")
        times.append([0.56, 1.16, 1.76, 2.36, 2.96])
        keys.append([[0.698132, [3, -0.2, 0], [3, 0.2, 0]], [-0.0872551, [3, -0.2, 0], [3, 0.2, 0]], [0.698132, [3, -0.2, 0], [3, 0.2, 0]], [-0.0872551, [3, -0.2, 0], [3, 0.2, 0]], [0.698434, [3, -0.2, 0], [3, 0, 0]]])
        names.append("LShoulderPitch")
        times.append([1.16, 2.36, 2.96])
        keys.append([[0, [3, -0.4, 0], [3, 0.4, 0]], [0, [3, -0.4, 0], [3, 0.2, 0]], [1.39513, [3, -0.2, 0], [3, 0, 0]]])
        names.append("LShoulderRoll")
        times.append([1.16, 2.36, 2.96])
        keys.append([[1.309, [3, -0.4, 0], [3, 0.4, 0]], [1.309, [3, -0.4, 0], [3, 0.2, 0]], [0.301781, [3, -0.2, 0], [3, 0, 0]]])
        names.append("LWristYaw")
        times.append([1.16, 2.36, 2.96])
        keys.append([[0, [3, -0.4, 0], [3, 0.4, 0]], [0, [3, -0.4, 0], [3, 0.2, 0]], [-0.00625175, [3, -0.2, 0], [3, 0, 0]]])
        names.append("RAnklePitch")
        times.append([0.56, 1.16, 1.76, 2.36, 2.96])
        keys.append([[-0.349066, [3, -0.2, 0], [3, 0.2, 0]], [0.0866825, [3, -0.2, 0], [3, 0.2, 0]], [-0.349066, [3, -0.2, 0], [3, 0.2, 0]], [0.0866825, [3, -0.2, 0], [3, 0.2, 0]], [-0.342458, [3, -0.2, 0], [3, 0, 0]]])
        names.append("RAnkleRoll")
        times.append([1.16, 2.36, 2.96])
        keys.append([[0.102612, [3, -0.4, 0], [3, 0.4, 0]], [0.102612, [3, -0.4, 0], [3, 0.2, 0]], [0.000801974, [3, -0.2, 0], [3, 0, 0]]])
        names.append("RElbowRoll")
        times.append([1.16, 2.36, 2.96])
        keys.append([[1.54462, [3, -0.4, 0], [3, 0.4, 0]], [1.54462, [3, -0.4, 0], [3, 0.2, 0]], [1.01186, [3, -0.2, 0], [3, 0, 0]]])
        names.append("RElbowYaw")
        times.append([0.56, 1.16, 1.76, 2.36, 2.96])
        keys.append([[-1.5708, [3, -0.2, 0], [3, 0.2, 0]], [1.5708, [3, -0.2, 0], [3, 0.2, 0]], [-1.5708, [3, -0.2, 0], [3, 0.2, 0]], [1.5708, [3, -0.2, 0], [3, 0.2, 0]], [1.39241, [3, -0.2, 0], [3, 0, 0]]])
        names.append("RHand")
        times.append([1.16, 2.36, 2.96])
        keys.append([[0.993634, [3, -0.4, 0], [3, 0.4, 0]], [0.993634, [3, -0.4, 0], [3, 0.2, 0]], [0.255812, [3, -0.2, 0], [3, 0, 0]]])
        names.append("RHipPitch")
        times.append([0.56, 1.16, 1.76, 2.36, 2.96])
        keys.append([[-0.349066, [3, -0.2, 0], [3, 0.2, 0]], [0.133733, [3, -0.2, 0], [3, 0.2, 0]], [-0.349066, [3, -0.2, 0], [3, 0.2, 0]], [0.133733, [3, -0.2, 0], [3, 0.2, 0]], [-0.45, [3, -0.2, 0], [3, 0, 0]]])
        names.append("RHipRoll")
        times.append([1.16, 2.36, 2.96])
        keys.append([[-0.115132, [3, -0.4, 0], [3, 0.4, 0]], [-0.115132, [3, -0.4, 0], [3, 0.2, 0]], [-0.00751719, [3, -0.2, 0], [3, 0, 0]]])
        names.append("RHipYawPitch")
        times.append([1.16, 2.36, 2.96])
        keys.append([[-0.171042, [3, -0.4, 0], [3, 0.4, 0]], [-0.171042, [3, -0.4, 0], [3, 0.2, 0]], [-0.0029538, [3, -0.2, 0], [3, 0, 0]]])
        names.append("RKneePitch")
        times.append([0.56, 1.16, 1.76, 2.36, 2.96])
        keys.append([[0.698132, [3, -0.2, 0], [3, 0.2, 0]], [-0.0872551, [3, -0.2, 0], [3, 0.2, 0]], [0.698132, [3, -0.2, 0], [3, 0.2, 0]], [-0.0872551, [3, -0.2, 0], [3, 0.2, 0]], [0.698434, [3, -0.2, 0], [3, 0, 0]]])
        names.append("RShoulderPitch")
        times.append([1.16, 2.36, 2.96])
        keys.append([[0, [3, -0.4, 0], [3, 0.4, 0]], [0, [3, -0.4, 0], [3, 0.2, 0]], [1.39513, [3, -0.2, 0], [3, 0, 0]]])
        names.append("RShoulderRoll")
        times.append([1.16, 2.36, 2.96])
        keys.append([[-1.309, [3, -0.4, 0], [3, 0.4, 0]], [-1.309, [3, -0.4, 0], [3, 0.2, 0]], [-0.301781, [3, -0.2, 0], [3, 0, 0]]])
        names.append("RWristYaw")
        times.append([1.16, 2.36, 2.96])
        keys.append([[0, [3, -0.4, 0], [3, 0.4, 0]], [0, [3, -0.4, 0], [3, 0.2, 0]], [0.00452276, [3, -0.2, 0], [3, 0, 0]]])
        try:
          # uncomment the following line and modify the IP if you use this script outside Choregraphe.
          # motion = ALProxy("ALMotion", IP, 9559)
          motion = ALProxy("ALMotion")
          motion.angleInterpolationBezier(names, times, keys)
        except BaseException, err:
          print err
          ##################################################################################################################################################################################################################################
    def clack(self):
        names = list()
        times = list()
        keys = list()
        names.append("HeadPitch")
        times.append([0.52, 0.84])
        keys.append([[-0.174171, [3, -0.186667, 0], [3, 0.106667, 0]], [-0.174171, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("HeadYaw")
        times.append([0.52, 0.84])
        keys.append([[-0.00695748, [3, -0.186667, 0], [3, 0.106667, 0]], [-0.00695748, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LAnklePitch")
        times.append([0.52, 0.84])
        keys.append([[0.0914655, [3, -0.186667, 0], [3, 0.106667, 0]], [0.0914655, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LAnkleRoll")
        times.append([0.52, 0.84])
        keys.append([[-0.101369, [3, -0.186667, 0], [3, 0.106667, 0]], [-0.101369, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LElbowRoll")
        times.append([0.52, 0.84])
        keys.append([[-0.422946, [3, -0.186667, 0], [3, 0.106667, 0]], [-0.422946, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LElbowYaw")
        times.append([0.52, 0.84])
        keys.append([[-1.20298, [3, -0.186667, 0], [3, 0.106667, 0]], [-1.20298, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LHand")
        times.append([0.52, 0.84])
        keys.append([[0.301882, [3, -0.186667, 0], [3, 0.106667, 0]], [0.301882, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LHipPitch")
        times.append([0.52, 0.84])
        keys.append([[0.127493, [3, -0.186667, 0], [3, 0.106667, 0]], [0.127493, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LHipRoll")
        times.append([0.52, 0.84])
        keys.append([[0.118347, [3, -0.186667, 0], [3, 0.106667, 0]], [0.118347, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LHipYawPitch")
        times.append([0.52, 0.84])
        keys.append([[-0.174671, [3, -0.186667, 0], [3, 0.106667, 0]], [-0.174671, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LKneePitch")
        times.append([0.52, 0.84])
        keys.append([[-0.0853155, [3, -0.186667, 0], [3, 0.106667, 0]], [-0.0853155, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LShoulderPitch")
        times.append([0.52, 0.84])
        keys.append([[1.43688, [3, -0.186667, 0], [3, 0.106667, 0]], [1.43688, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LShoulderRoll")
        times.append([0.52, 0.84])
        keys.append([[0.223158, [3, -0.186667, 0], [3, 0.106667, 0]], [0.223158, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("LWristYaw")
        times.append([0.52, 0.84])
        keys.append([[0.0984751, [3, -0.186667, 0], [3, 0.106667, 0]], [0.0984751, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RAnklePitch")
        times.append([0.52, 0.84])
        keys.append([[0.0882887, [3, -0.186667, 0], [3, 0.106667, 0]], [0.0882887, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RAnkleRoll")
        times.append([0.52, 0.84])
        keys.append([[0.113558, [3, -0.186667, 0], [3, 0.106667, 0]], [0.113558, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RElbowRoll")
        times.append([0.52, 0.84])
        keys.append([[1.54266, [3, -0.186667, 0], [3, 0.106667, 0]], [1.54266, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RElbowYaw")
        times.append([0.52, 0.84])
        keys.append([[2.08038, [3, -0.186667, 0], [3, 0.106667, 0]], [2.08038, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RHand")
        times.append([0.36, 0.52, 0.68, 0.84])
        keys.append([[0.56, [3, -0.133333, 0], [3, 0.0533333, 0]], [0.2, [3, -0.0533333, 0], [3, 0.0533333, 0]], [0.56, [3, -0.0533333, 0], [3, 0.0533333, 0]], [0.2, [3, -0.0533333, 0], [3, 0, 0]]])
        names.append("RHipPitch")
        times.append([0.52, 0.84])
        keys.append([[0.128033, [3, -0.186667, 0], [3, 0.106667, 0]], [0.128033, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RHipRoll")
        times.append([0.52, 0.84])
        keys.append([[-0.116214, [3, -0.186667, 0], [3, 0.106667, 0]], [-0.116214, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RHipYawPitch")
        times.append([0.52, 0.84])
        keys.append([[-0.174671, [3, -0.186667, 0], [3, 0.106667, 0]], [-0.174671, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RKneePitch")
        times.append([0.52, 0.84])
        keys.append([[-0.0826476, [3, -0.186667, 0], [3, 0.106667, 0]], [-0.0826476, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RShoulderPitch")
        times.append([0.52, 0.84])
        keys.append([[1.46879, [3, -0.186667, 0], [3, 0.106667, 0]], [1.46879, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RShoulderRoll")
        times.append([0.52, 0.84])
        keys.append([[-0.0951325, [3, -0.186667, 0], [3, 0.106667, 0]], [-0.0951325, [3, -0.106667, 0], [3, 0, 0]]])
        names.append("RWristYaw")
        times.append([0.52, 0.84])
        keys.append([[0.748296, [3, -0.186667, 0], [3, 0.106667, 0]], [0.748296, [3, -0.106667, 0], [3, 0, 0]]])
        try:
          # uncomment the following line and modify the IP if you use this script outside Choregraphe.
          # motion = ALProxy("ALMotion", IP, 9559)
          motion = ALProxy("ALMotion")
          motion.angleInterpolationBezier(names, times, keys)
        except BaseException, err:
          print err

    def technologic(self):
            ttsProxy = ALProxy("ALTextToSpeech")
            self.clack()
            time.sleep(0.4)
            ttsProxy.say("Technologic")
            time.sleep(0.4)
            self.clack()
            time.sleep(0.4)
            ttsProxy.say("Technologic")
            time.sleep(0.4)
            self.clack()
            time.sleep(0.4)
            ttsProxy.say("Technologic")
            time.sleep(0.4)
            self.clack()
            time.sleep(0.4)
            ttsProxy.say("Technologic")
###################################################################################################################################################################################################################################################################
    def sit(self):
        names = list()
        times = list()
        keys = list()
        names.append("HeadPitch")
        times.append([0.96])
        keys.append([[-0.0367564, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("HeadYaw")
        times.append([0.96])
        keys.append([[-0.0400697, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LAnklePitch")
        times.append([0.96])
        keys.append([[0.835988, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LAnkleRoll")
        times.append([0.96])
        keys.append([[-0.0173474, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LElbowRoll")
        times.append([0.96])
        keys.append([[-1.20972, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LElbowYaw")
        times.append([0.96])
        keys.append([[-0.449659, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LHand")
        times.append([0.96])
        keys.append([[0.295692, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LHipPitch")
        times.append([0.96])
        keys.append([[-1.53247, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LHipRoll")
        times.append([0.96])
        keys.append([[0.269735, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LHipYawPitch")
        times.append([0.96])
        keys.append([[-0.619608, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LKneePitch")
        times.append([0.96])
        keys.append([[1.39157, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LShoulderPitch")
        times.append([0.96])
        keys.append([[0.833979, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LShoulderRoll")
        times.append([0.96])
        keys.append([[0.267669, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("LWristYaw")
        times.append([0.96])
        keys.append([[0.0317215, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RAnklePitch")
        times.append([0.96])
        keys.append([[0.849878, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RAnkleRoll")
        times.append([0.96])
        keys.append([[0.0260041, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RElbowRoll")
        times.append([0.96])
        keys.append([[1.26105, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RElbowYaw")
        times.append([0.96])
        keys.append([[0.516621, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RHand")
        times.append([0.96])
        keys.append([[0.299793, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RHipPitch")
        times.append([0.96])
        keys.append([[-1.53534, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RHipRoll")
        times.append([0.96])
        keys.append([[-0.26058, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RHipYawPitch")
        times.append([0.96])
        keys.append([[-0.619608, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RKneePitch")
        times.append([0.96])
        keys.append([[1.4013, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RShoulderPitch")
        times.append([0.96])
        keys.append([[0.889028, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RShoulderRoll")
        times.append([0.96])
        keys.append([[-0.310889, [3, -0.333333, 0], [3, 0, 0]]])
        names.append("RWristYaw")
        times.append([0.96])
        keys.append([[-0.0265908, [3, -0.333333, 0], [3, 0, 0]]])
        try:
          # uncomment the following line and modify the IP if you use this script outside Choregraphe.
          # motion = ALProxy("ALMotion", IP, 9559)
          motion = ALProxy("ALMotion")
          motion.angleInterpolationBezier(names, times, keys)
        except BaseException, err:
          print err
    def standZero(self):
        names = list()
        times = list()
        keys = list()

        names.append("HeadPitch")
        times.append([0.32])
        keys.append([-0.00883599])

        names.append("HeadYaw")
        times.append([0.32])
        keys.append([-0.00361372])

        names.append("LAnklePitch")
        times.append([0.32])
        keys.append([-0.00688659])

        names.append("LAnkleRoll")
        times.append([0.32])
        keys.append([-0.00532647])

        names.append("LElbowRoll")
        times.append([0.32])
        keys.append([-0.0413811])

        names.append("LElbowYaw")
        times.append([0.32])
        keys.append([-0.00261218])

        names.append("LHand")
        times.append([0.32])
        keys.append([0.000567943])

        names.append("LHipPitch")
        times.append([0.32])
        keys.append([-0.00885419])

        names.append("LHipRoll")
        times.append([0.32])
        keys.append([0.00546251])

        names.append("LHipYawPitch")
        times.append([0.32])
        keys.append([-0.00864068])

        names.append("LKneePitch")
        times.append([0.32])
        keys.append([0.00159024])

        names.append("LShoulderPitch")
        times.append([0.32])
        keys.append([0.00263098])

        names.append("LShoulderRoll")
        times.append([0.32])
        keys.append([0.0146277])

        names.append("LWristYaw")
        times.append([0.32])
        keys.append([0.00138806])

        names.append("RAnklePitch")
        times.append([0.32])
        keys.append([-0.00688659])

        names.append("RAnkleRoll")
        times.append([0.32])
        keys.append([0.00188465])

        names.append("RElbowRoll")
        times.append([0.32])
        keys.append([0.0413811])

        names.append("RElbowYaw")
        times.append([0.32])
        keys.append([0.00261218])

        names.append("RHand")
        times.append([0.32])
        keys.append([0.000567943])

        names.append("RHipPitch")
        times.append([0.32])
        keys.append([-0.00885419])

        names.append("RHipRoll")
        times.append([0.32])
        keys.append([-0.0054632])

        names.append("RHipYawPitch")
        times.append([0.32])
        keys.append([-0.00864068])

        names.append("RKneePitch")
        times.append([0.32])
        keys.append([0.00159024])

        names.append("RShoulderPitch")
        times.append([0.32])
        keys.append([0.00263098])

        names.append("RShoulderRoll")
        times.append([0.32])
        keys.append([-0.0146277])

        names.append("RWristYaw")
        times.append([0.32])
        keys.append([0.00135808])

        try:
          # uncomment the following line and modify the IP if you use this script outside Choregraphe.
          # motion = ALProxy("ALMotion", IP, 9559)
          motion = ALProxy("ALMotion")
          motion.angleInterpolation(names, keys, times, True)
        except BaseException, err:
          print err

    def stand(self):

        names = list()
        times = list()
        keys = list()

        names.append("HeadPitch")
        times.append([0.4])
        keys.append([-0.168637])

        names.append("HeadYaw")
        times.append([0.4])
        keys.append([-0.00361372])

        names.append("LAnklePitch")
        times.append([0.4])
        keys.append([0.0815694])

        names.append("LAnkleRoll")
        times.append([0.4])
        keys.append([-0.100899])

        names.append("LElbowRoll")
        times.append([0.4])
        keys.append([-0.415277])

        names.append("LElbowYaw")
        times.append([0.4])
        keys.append([-1.20047])

        names.append("LHand")
        times.append([0.4])
        keys.append([0.290728])

        names.append("LHipPitch")
        times.append([0.4])
        keys.append([0.126397])

        names.append("LHipRoll")
        times.append([0.4])
        keys.append([0.119108])

        names.append("LHipYawPitch")
        times.append([0.4])
        keys.append([-0.168646])

        names.append("LKneePitch")
        times.append([0.4])
        keys.append([-0.0840831])

        names.append("LShoulderPitch")
        times.append([0.4])
        keys.append([1.43993])

        names.append("LShoulderRoll")
        times.append([0.4])
        keys.append([0.215231])

        names.append("LWristYaw")
        times.append([0.4])
        keys.append([0.0912954])

        names.append("RAnklePitch")
        times.append([0.4])
        keys.append([0.0815693])

        names.append("RAnkleRoll")
        times.append([0.4])
        keys.append([0.100896])

        names.append("RElbowRoll")
        times.append([0.4])
        keys.append([0.415277])

        names.append("RElbowYaw")
        times.append([0.4])
        keys.append([1.20047])

        names.append("RHand")
        times.append([0.4])
        keys.append([0.290728])

        names.append("RHipPitch")
        times.append([0.4])
        keys.append([0.126397])

        names.append("RHipRoll")
        times.append([0.4])
        keys.append([-0.119102])

        names.append("RHipYawPitch")
        times.append([0.4])
        keys.append([-0.168646])

        names.append("RKneePitch")
        times.append([0.4])
        keys.append([-0.0840831])

        names.append("RShoulderPitch")
        times.append([0.4])
        keys.append([1.43993])

        names.append("RShoulderRoll")
        times.append([0.4])
        keys.append([-0.215231])

        names.append("RWristYaw")
        times.append([0.4])
        keys.append([0.0912954])

        try:
          # uncomment the following line and modify the IP if you use this script outside Choregraphe.
          # motion = ALProxy("ALMotion", IP, 9559)
          motion = ALProxy("ALMotion")
          motion.angleInterpolation(names, keys, times, True)
        except BaseException, err:
          print err

    def sitRelax(self):
        try:
            postureProxy = ALProxy("ALRobotPosture")
        except Exception, e:
            print "Could not create proxy to ALRobotPosture"
            print "Error was: ", e
        postureProxy.goToPosture("SitRelax", 1.0)

    def crouch(self):
        try:
            postureProxy = ALProxy("ALRobotPosture")
        except Exception, e:
            print "Could not create proxy to ALRobotPosture"
            print "Error was: ", e
        postureProxy.goToPosture("Crouch", 1.0)

###################################################################################################################################################################################################################################################################

    def hello(self):
        names = list()
        times = list()
        keys = list()

        names.append("HeadPitch")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[-0.167559, [3, -0.0133333, 0], [3, 0.186667, 0]], [-0.169033, [3, -0.186667, 2.33027e-08], [3, 0.266667, -3.32895e-08]], [-0.169033, [3, -0.266667, 0], [3, 0.266667, 0]], [-0.167559, [3, -0.266667, 0], [3, 0.2, 0]], [-0.167559, [3, -0.2, 0], [3, 0, 0]]])

        names.append("HeadYaw")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[0, [3, -0.0133333, 0], [3, 0.186667, 0]], [0, [3, -0.186667, 0], [3, 0.266667, 0]], [0, [3, -0.266667, 0], [3, 0.266667, 0]], [0, [3, -0.266667, 0], [3, 0.2, 0]], [0, [3, -0.2, 0], [3, 0, 0]]])

        names.append("LAnklePitch")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[0.0828792, [3, -0.0133333, 0], [3, 0.186667, 0]], [0.0828792, [3, -0.186667, 0], [3, 0.266667, 0]], [0.0828792, [3, -0.266667, 0], [3, 0.266667, 0]], [0.0828792, [3, -0.266667, 0], [3, 0.2, 0]], [0.0828792, [3, -0.2, 0], [3, 0, 0]]])

        names.append("LAnkleRoll")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[-0.104266, [3, -0.0133333, 0], [3, 0.186667, 0]], [-0.106419, [3, -0.186667, 0], [3, 0.266667, 0]], [-0.106419, [3, -0.266667, 0], [3, 0.266667, 0]], [-0.104266, [3, -0.266667, 0], [3, 0.2, 0]], [-0.104266, [3, -0.2, 0], [3, 0, 0]]])

        names.append("LElbowRoll")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[-0.422033, [3, -0.0133333, 0], [3, 0.186667, 0]], [-0.417736, [3, -0.186667, -1.16513e-07], [3, 0.266667, 1.66448e-07]], [-0.417736, [3, -0.266667, 0], [3, 0.266667, 0]], [-0.422033, [3, -0.266667, 0], [3, 0.2, 0]], [-0.422033, [3, -0.2, 0], [3, 0, 0]]])

        names.append("LElbowYaw")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[-1.19653, [3, -0.0133333, 0], [3, 0.186667, 0]], [-1.19421, [3, -0.186667, -9.32106e-08], [3, 0.266667, 1.33158e-07]], [-1.19421, [3, -0.266667, 0], [3, 0.266667, 0]], [-1.19653, [3, -0.266667, 0], [3, 0.2, 0]], [-1.19653, [3, -0.2, 0], [3, 0, 0]]])

        names.append("LHand")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[0.294017, [3, -0.0133333, 0], [3, 0.186667, 0]], [0.295804, [3, -0.186667, 0], [3, 0.266667, 0]], [0.295804, [3, -0.266667, 2.98023e-08], [3, 0.266667, -2.98023e-08]], [0.294017, [3, -0.266667, 0], [3, 0.2, 0]], [0.294017, [3, -0.2, 0], [3, 0, 0]]])

        names.append("LHipPitch")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[0.126342, [3, -0.0133333, 0], [3, 0.186667, 0]], [0.126342, [3, -0.186667, 0], [3, 0.266667, 0]], [0.126342, [3, -0.266667, 0], [3, 0.266667, 0]], [0.126342, [3, -0.266667, 0], [3, 0.2, 0]], [0.126342, [3, -0.2, 0], [3, 0, 0]]])

        names.append("LHipRoll")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[0.117724, [3, -0.0133333, 0], [3, 0.186667, 0]], [0.110438, [3, -0.186667, 0], [3, 0.266667, 0]], [0.110439, [3, -0.266667, -2.49671e-08], [3, 0.266667, 2.49671e-08]], [0.117724, [3, -0.266667, 0], [3, 0.2, 0]], [0.117724, [3, -0.2, 0], [3, 0, 0]]])

        names.append("LHipYawPitch")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[-0.173871, [3, -0.0133333, 0], [3, 0.186667, 0]], [-0.171873, [3, -0.186667, -1.16513e-08], [3, 0.266667, 1.66448e-08]], [-0.171873, [3, -0.266667, 0], [3, 0.266667, 0]], [-0.173871, [3, -0.266667, 0], [3, 0.2, 0]], [-0.173871, [3, -0.2, 0], [3, 0, 0]]])

        names.append("LKneePitch")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[-0.0844386, [3, -0.0133333, 0], [3, 0.186667, 0]], [-0.089461, [3, -0.186667, 2.91283e-08], [3, 0.266667, -4.16119e-08]], [-0.089461, [3, -0.266667, 0], [3, 0.266667, 0]], [-0.0844387, [3, -0.266667, 0], [3, 0.2, 0]], [-0.0844387, [3, -0.2, 0], [3, 0, 0]]])

        names.append("LShoulderPitch")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[1.43551, [3, -0.0133333, 0], [3, 0.186667, 0]], [1.42281, [3, -0.186667, 9.32106e-08], [3, 0.266667, -1.33158e-07]], [1.42281, [3, -0.266667, 0], [3, 0.266667, 0]], [1.43551, [3, -0.266667, 0], [3, 0.2, 0]], [1.43551, [3, -0.2, 0], [3, 0, 0]]])

        names.append("LShoulderRoll")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[0.221489, [3, -0.0133333, 0], [3, 0.186667, 0]], [0.244456, [3, -0.186667, 0], [3, 0.266667, 0]], [0.244456, [3, -0.266667, 2.16382e-07], [3, 0.266667, -2.16382e-07]], [0.221489, [3, -0.266667, 0], [3, 0.2, 0]], [0.221489, [3, -0.2, 0], [3, 0, 0]]])

        names.append("LWristYaw")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[0.101125, [3, -0.0133333, 0], [3, 0.186667, 0]], [0.100965, [3, -0.186667, 2.33027e-08], [3, 0.266667, -3.32895e-08]], [0.100965, [3, -0.266667, 0], [3, 0.266667, 0]], [0.101125, [3, -0.266667, 0], [3, 0.2, 0]], [0.101125, [3, -0.2, 0], [3, 0, 0]]])

        names.append("RAnklePitch")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[0.0828791, [3, -0.0133333, 0], [3, 0.186667, 0]], [0.0828791, [3, -0.186667, 0], [3, 0.266667, 0]], [0.0828791, [3, -0.266667, 0], [3, 0.266667, 0]], [0.0828791, [3, -0.266667, 0], [3, 0.2, 0]], [0.0828791, [3, -0.2, 0], [3, 0, 0]]])

        names.append("RAnkleRoll")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[0.104262, [3, -0.0133333, 0], [3, 0.186667, 0]], [0.103458, [3, -0.186667, 4.66053e-08], [3, 0.266667, -6.6579e-08]], [0.103458, [3, -0.266667, 0], [3, 0.266667, 0]], [0.104262, [3, -0.266667, 0], [3, 0.2, 0]], [0.104262, [3, -0.2, 0], [3, 0, 0]]])

        names.append("RElbowRoll")
        times.append([0, 0.56, 0.96, 1.36, 1.76, 2.16, 2.76])
        keys.append([[0.422035, [3, -0.0133333, 0], [3, 0.186667, 0]], [0.43849, [3, -0.186667, -0.0164552], [3, 0.133333, 0.0117537]], [1.54462, [3, -0.133333, 0], [3, 0.133333, 0]], [0.43849, [3, -0.133333, 0], [3, 0.133333, 0]], [1.54462, [3, -0.133333, 0], [3, 0.133333, 0]], [0.422035, [3, -0.133333, 0], [3, 0.2, 0]], [0.422035, [3, -0.2, 0], [3, 0, 0]]])

        names.append("RElbowYaw")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[1.19653, [3, -0.0133333, 0], [3, 0.186667, 0]], [-0.00652, [3, -0.186667, 0], [3, 0.266667, 0]], [-0.00651999, [3, -0.266667, -7.28208e-09], [3, 0.266667, 7.28208e-09]], [1.19653, [3, -0.266667, 0], [3, 0.2, 0]], [1.19653, [3, -0.2, 0], [3, 0, 0]]])

        names.append("RHand")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[0.294017, [3, -0.0133333, 0], [3, 0.186667, 0]], [0.994627, [3, -0.186667, -1.66893e-07], [3, 0.266667, 2.38419e-07]], [0.994627, [3, -0.266667, 0], [3, 0.266667, 0]], [0.294017, [3, -0.266667, 0], [3, 0.2, 0]], [0.294017, [3, -0.2, 0], [3, 0, 0]]])

        names.append("RHipPitch")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[0.126342, [3, -0.0133333, 0], [3, 0.186667, 0]], [0.126342, [3, -0.186667, 0], [3, 0.266667, 0]], [0.126342, [3, -0.266667, 0], [3, 0.266667, 0]], [0.126342, [3, -0.266667, 0], [3, 0.2, 0]], [0.126342, [3, -0.2, 0], [3, 0, 0]]])

        names.append("RHipRoll")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[-0.117718, [3, -0.0133333, 0], [3, 0.186667, 0]], [-0.110433, [3, -0.186667, 0], [3, 0.266667, 0]], [-0.110433, [3, -0.266667, 1.66448e-08], [3, 0.266667, -1.66448e-08]], [-0.117718, [3, -0.266667, 0], [3, 0.2, 0]], [-0.117718, [3, -0.2, 0], [3, 0, 0]]])

        names.append("RHipYawPitch")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[-0.173871, [3, -0.0133333, 0], [3, 0.186667, 0]], [-0.171873, [3, -0.186667, -1.16513e-08], [3, 0.266667, 1.66448e-08]], [-0.171873, [3, -0.266667, 0], [3, 0.266667, 0]], [-0.173871, [3, -0.266667, 0], [3, 0.2, 0]], [-0.173871, [3, -0.2, 0], [3, 0, 0]]])

        names.append("RKneePitch")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[-0.0844386, [3, -0.0133333, 0], [3, 0.186667, 0]], [-0.089461, [3, -0.186667, 2.91283e-08], [3, 0.266667, -4.16119e-08]], [-0.089461, [3, -0.266667, 0], [3, 0.266667, 0]], [-0.0844387, [3, -0.266667, 0], [3, 0.2, 0]], [-0.0844387, [3, -0.2, 0], [3, 0, 0]]])

        names.append("RShoulderPitch")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[1.44097, [3, -0.0133333, 0], [3, 0.186667, 0]], [-1.04416, [3, -0.186667, 2.79632e-07], [3, 0.266667, -3.99474e-07]], [-1.04416, [3, -0.266667, 0], [3, 0.266667, 0]], [1.44097, [3, -0.266667, 0], [3, 0.2, 0]], [1.44097, [3, -0.2, 0], [3, 0, 0]]])

        names.append("RShoulderRoll")
        times.append([0, 0.56, 1.36, 2.16, 2.76])
        keys.append([[-0.221019, [3, -0.0133333, 0], [3, 0.186667, 0]], [-0.998278, [3, -0.186667, 0], [3, 0.266667, 0]], [-0.998278, [3, -0.266667, -6.6579e-08], [3, 0.266667, 6.6579e-08]], [-0.221018, [3, -0.266667, 0], [3, 0.2, 0]], [-0.221018, [3, -0.2, 0], [3, 0, 0]]])

        names.append("RWristYaw")
        times.append([0, 0.56, 0.96, 1.36, 1.76, 2.16, 2.76])
        keys.append([[0.0943753, [3, -0.0133333, 0], [3, 0.186667, 0]], [0.099632, [3, -0.186667, 0], [3, 0.133333, 0]], [0, [3, -0.133333, 0], [3, 0.133333, 0]], [0.0996319, [3, -0.133333, 0], [3, 0.133333, 0]], [0, [3, -0.133333, 0], [3, 0.133333, 0]], [0.0943752, [3, -0.133333, 0], [3, 0.2, 0]], [0.0943752, [3, -0.2, 0], [3, 0, 0]]])

        try:
            motion = ALProxy("ALMotion")
            motion.angleInterpolationBezier(names, times, keys)
        except BaseException, err:
            print err]]>
                </content>
              </script>
              <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
              <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
              <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
              <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
            </Box>
            <Box name="Play Sound" id="7" localization="8" tooltip="Play a sound file. Select the file in parameters. The format of the file can be wav or ogg (on virtual robot) and also mp3 (on a real robot).&#x0A;&#x0A;Note: There can be some delay to play ogg or mp3 (on a robot) files. We advise you to use wav if&#x0A;you want a fast play of the file." x="409" y="437">
              <bitmap>media/images/box/interaction/play_music.png</bitmap>
              <script language="4">
                <content>
                  <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        self.bIsRunning = False

    def onUnload(self):
        self.bIsRunning = False

    def onInput_onStart(self):
        self.bIsRunning = True

    def onInput_onStop(self):
        if( self.bIsRunning ):
            self.onUnload()
            self.onStopped()]]>
                </content>
              </script>
              <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when Diagram is loaded." id="1" />
              <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Starts the music." id="2" />
              <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stops the music." id="3" />
              <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished or stopped." id="4" />
              <Parameter name="File name" inherits_from_parent="0" content_type="4" value="/../techn.wav" default_value="" tooltip="Name of the file you want to play.&#x0A;&#x0A;Note: You can click on the folder icon to browse the project content or import&#x0A;new files to the project." id="5" />
              <Parameter name="Begin position (s)" inherits_from_parent="0" content_type="2" value="0" default_value="0" min="0" max="600" tooltip="Position in seconds where the playing must start." id="6" />
              <Parameter name="Volume (%)" inherits_from_parent="0" content_type="1" value="100" default_value="100" min="0" max="100" tooltip="Volume the file is played with." id="7" />
              <Parameter name="Balance L/R" inherits_from_parent="0" content_type="2" value="0" default_value="0" min="-1" max="1" tooltip="Value which determines if the sound is played more on the robot&apos;s left or right.&#x0A;You can particularly set it to:&#x0A;- -1 to play only on the left loudspeaker.&#x0A;- 0 to play on both loudspeakers.&#x0A;- 1 to play only on the right loudspeaker." id="8" />
              <Parameter name="Play in loop" inherits_from_parent="0" content_type="0" value="0" default_value="0" tooltip="This parameter allows to play the file in loop. The playing will start each time at&#x0A;the beginning of the file." id="9" />
              <Timeline enable="0">
                <BehaviorLayer name="behavior_layer1">
                  <BehaviorKeyframe name="keyframe1" index="1">
                    <Diagram>
                      <Box name="Play Sound File" id="2" localization="8" tooltip="Play the sound." x="442" y="70">
                        <bitmap>media/images/box/interaction/play_music.png</bitmap>
                        <script language="4">
                          <content>
                            <![CDATA[import time

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        self.player = self.session().service('ALAudioPlayer')
        self.playerStop = self.session().service('ALAudioPlayer') #Create another service as wait is blocking if audioout is remote
        self.bIsRunning = False
        self.ids = []

    def onUnload(self):
        for id in self.ids:
            try:
                self.playerStop.stop(id)
            except:
                pass
        while( self.bIsRunning ):
            time.sleep( 0.2 )

    def onInput_onStart(self, p):
        self.bIsRunning = True
        try:
            if (self.getParameter("Play in loop")) :
               id = self.player.pCall("playFileInLoop",p,self.getParameter("Volume (%)")/100.,self.getParameter("Balance L/R"))
            else :
               id = self.player.pCall("playFileFromPosition",p,self.getParameter("Begin position (s)"),self.getParameter("Volume (%)")/100.,self.getParameter("Balance L/R"))
            self.ids.append(id)
            self.player.wait(id)
        finally:
            try:
                self.ids.remove(id)
            except:
                pass
            if( self.ids == [] ):
                self.onStopped() # activate output of the box
                self.bIsRunning = False

    def onInput_onStop(self):
        self.onUnload()]]>
                          </content>
                        </script>
                        <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when Diagram is loaded." id="1" />
                        <Input name="onStart" type="3" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this Input." id="2" />
                        <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this Input." id="3" />
                        <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when Box behavior is finished." id="4" />
                        <Parameter name="Begin position (s)" inherits_from_parent="1" content_type="2" value="0" default_value="0" min="0" max="600" tooltip="Position in seconds where the playing must start." id="5" />
                        <Parameter name="Volume (%)" inherits_from_parent="1" content_type="1" value="100" default_value="100" min="0" max="100" tooltip="Volume the file is played with." id="6" />
                        <Parameter name="Balance L/R" inherits_from_parent="1" content_type="2" value="0" default_value="0" min="-1" max="1" tooltip="Value which determines if the sound is played more on the robot&apos;s left or right.&#x0A;You can particularly set it to:&#x0A;- -1 to play only on the left loudspeaker.&#x0A;- 0 to play on both loudspeakers.&#x0A;- 1 to play only on the right loudspeaker." id="7" />
                        <Parameter name="Play in loop" inherits_from_parent="1" content_type="0" value="0" default_value="0" tooltip="This parameter allows to play the file in loop. The playing will start each time at&#x0A;the beginning of the file." id="8" />
                      </Box>
                      <Box name="Get Attached File" id="1" localization="8" tooltip="Use this box to choose an attached file in its parameters. The filename will be sent on&#x0A;the output when the input is stimulated." x="216" y="71">
                        <bitmap>media/images/box/folder.png</bitmap>
                        <script language="4">
                          <content>
                            <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        pass

    def onInput_onStart(self):
        self.onStopped(self.behaviorAbsolutePath() + self.getParameter("File name"))]]>
                          </content>
                        </script>
                        <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                        <Input name="onStart" type="1" type_size="1" nature="1" inner="0" tooltip="To send the filepath on the output." id="2" />
                        <Output name="onStopped" type="3" type_size="1" nature="2" inner="0" tooltip="The filepath of the selected resource file." id="3" />
                        <Parameter name="File name" inherits_from_parent="1" content_type="4" value="" default_value="" tooltip="Name of the file which is going to be sent on the box output.&#x0A;&#x0A;Note: You can click on the folder icon to browse the project content or import&#x0A;new files to the project." id="4" />
                      </Box>
                      <Link inputowner="0" indexofinput="4" outputowner="2" indexofoutput="4" />
                      <Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="2" />
                      <Link inputowner="2" indexofinput="2" outputowner="1" indexofoutput="3" />
                    </Diagram>
                  </BehaviorKeyframe>
                </BehaviorLayer>
              </Timeline>
              <Resource name="Audio player" type="Lock" timeout="0" />
            </Box>
            <Link inputowner="0" indexofinput="4" outputowner="4" indexofoutput="4" />
            <Link inputowner="0" indexofinput="4" outputowner="7" indexofoutput="4" />
            <Link inputowner="7" indexofinput="2" outputowner="0" indexofoutput="2" />
            <Link inputowner="4" indexofinput="2" outputowner="0" indexofoutput="2" />
          </Diagram>
        </BehaviorKeyframe>
      </BehaviorLayer>
    </Timeline>
  </Box>
</ChoregrapheProject>
